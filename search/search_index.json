{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Integraci\u00f3n de Spring Boot con PayPal y Buenas Pr\u00e1cticas","text":""},{"location":"#descripcion-del-taller","title":"Descripci\u00f3n del Taller","text":"<p>En este taller interactivo, aprender\u00e1s paso a paso c\u00f3mo integrar la plataforma de pagos PayPal en aplicaciones desarrolladas con Spring Boot. Abordaremos las t\u00e9cnicas necesarias para manejar pagos en l\u00ednea de manera segura y eficiente, un requisito esencial para cualquier negocio digital. Adicionalmente, exploraremos c\u00f3mo mejorar el rendimiento de tu aplicaci\u00f3n mediante el uso de caching con Redis, c\u00f3mo personalizar tu aplicaci\u00f3n creando anotaciones con Spring Aspect-Oriented Programming (AOP), y c\u00f3mo garantizar la calidad de tu software a trav\u00e9s de pruebas efectivas en Spring. Estas habilidades son cruciales para construir aplicaciones comerciales robustas y escalables.</p>"},{"location":"#introduccion","title":"Introducci\u00f3n","text":"<p>En este taller, aprender\u00e1s a integrar PayPal con aplicaciones Spring Boot, implementar caching con Redis, crear anotaciones personalizadas con Spring AOP, y realizar pruebas efectivas. Estas habilidades son esenciales para desarrollar aplicaciones comerciales robustas y escalables.</p>"},{"location":"#requisitos","title":"Requisitos","text":"<ul> <li>Java: Versi\u00f3n 21.</li> <li>Spring Boot: Versi\u00f3n 3.2.x o superior.</li> <li>Base de Datos: PostgreSQL.</li> <li>Redis: Utilizado para implementar el caching y mejorar el rendimiento.</li> <li>IDE (Entorno de Desarrollo Integrado): IntelliJ IDEA, Eclipse, o cualquier otro de tu preferencia.</li> <li>Cuenta de PayPal Developer: Necesaria para obtener las credenciales de desarrollo.</li> <li>Herramientas de Construcci\u00f3n: Maven o Gradle.</li> <li>Docker: Utilizado para la creaci\u00f3n y gesti\u00f3n de contenedores, facilitando un entorno de desarrollo consistente y f\u00e1cil de replicar.</li> </ul>"},{"location":"#arquitectura-tecnica-y-servicios-backend","title":"Arquitectura T\u00e9cnica y Servicios Backend","text":""},{"location":"#descripcion-del-diagrama-de-la-aplicacion-bookstore-con-integracion-de-paypal","title":"Descripci\u00f3n del Diagrama de la Aplicaci\u00f3n BookStore con Integraci\u00f3n de PayPal","text":"<p>Este diagrama ilustra el flujo de trabajo de la integraci\u00f3n de PayPal en la aplicaci\u00f3n BookStore. A continuaci\u00f3n, se detallan cada uno de los componentes y sus interacciones:</p> <ol> <li> <p>Frontend del Usuario (Cliente Web)</p> <ul> <li>Descripci\u00f3n: Es la interfaz que el usuario final utiliza para interactuar con la aplicaci\u00f3n BookStore. Desde aqu\u00ed, el usuario puede navegar por la tienda, seleccionar libros y proceder al pago.</li> <li>Interacci\u00f3n: El usuario realiza acciones en el cliente web que se comunican con la <code>Backend App BookStore</code> para solicitar datos o realizar transacciones.</li> </ul> </li> <li> <p>Backend App BookStore</p> <ul> <li>Descripci\u00f3n: Es el n\u00facleo de la aplicaci\u00f3n, donde se maneja la l\u00f3gica de negocio. Esta capa se encarga de procesar las solicitudes del cliente web, interactuar con la base de datos, gestionar pagos y enviar notificaciones por correo electr\u00f3nico.</li> <li>Interacciones:<ul> <li>Con el Cliente Web: Recibe solicitudes y env\u00eda respuestas para las acciones del usuario.</li> <li>Con PayPal Backend:<ul> <li>Env\u00eda solicitudes de pago a PayPal cuando un usuario realiza una compra.</li> <li>Recibe las confirmaciones de pago de PayPal.</li> </ul> </li> <li>Con la Base de Datos: Lee y escribe datos como informaci\u00f3n de libros, detalles de usuarios y transacciones.</li> <li>Con el Servicio de Email: Env\u00eda correos electr\u00f3nicos de confirmaci\u00f3n de pedidos y otras notificaciones relevantes al usuario.</li> </ul> </li> </ul> </li> <li> <p>PayPal Backend</p> <ul> <li>Descripci\u00f3n: Servicio externo proporcionado por PayPal que gestiona las transacciones de pago.</li> <li>Interacciones:<ul> <li>Con Backend App BookStore:<ul> <li>Recibe solicitudes de pago desde la <code>Backend App BookStore</code>.</li> <li>Env\u00eda respuestas de confirmaci\u00f3n o rechazo de las transacciones a la <code>Backend App BookStore</code>.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Base de Datos</p> <ul> <li>Descripci\u00f3n: Almacena todos los datos relevantes de la aplicaci\u00f3n, incluyendo informaci\u00f3n de productos (libros), usuarios, y transacciones.</li> <li>Interacciones:<ul> <li>Con Backend App BookStore: Proporciona datos necesarios para la l\u00f3gica de negocio y almacena los resultados de las operaciones de la aplicaci\u00f3n.</li> </ul> </li> </ul> </li> <li> <p>Servicio de Email</p> <ul> <li>Descripci\u00f3n: Gestiona el env\u00edo de correos electr\u00f3nicos a los usuarios.</li> <li>Interacciones:<ul> <li>Con Backend App BookStore: Recibe solicitudes para enviar correos electr\u00f3nicos de confirmaci\u00f3n de pedidos y otras notificaciones importantes.</li> </ul> </li> </ul> </li> </ol>"},{"location":"#flujo-de-trabajo","title":"Flujo de Trabajo","text":"<ol> <li> <p>Inicio de Transacci\u00f3n</p> <ul> <li>El usuario navega por la tienda en el cliente web y selecciona los libros que desea comprar.</li> <li>Al proceder al pago, la solicitud se env\u00eda desde el cliente web a la <code>Backend App BookStore</code>.</li> </ul> </li> <li> <p>Procesamiento del Pago</p> <ul> <li>La <code>Backend App BookStore</code> recibe la solicitud de pago y env\u00eda una solicitud a PayPal para procesar el pago.</li> <li>PayPal procesa el pago y env\u00eda una respuesta de confirmaci\u00f3n o rechazo a la <code>Backend App BookStore</code>.</li> </ul> </li> <li> <p>Actualizaci\u00f3n de la Base de Datos</p> <ul> <li>Una vez confirmado el pago, la <code>Backend App BookStore</code> actualiza la base de datos con la informaci\u00f3n de la transacci\u00f3n.</li> </ul> </li> <li> <p>Notificaci\u00f3n al Usuario</p> <ul> <li>La <code>Backend App BookStore</code> env\u00eda una solicitud al Servicio de Email para enviar una confirmaci\u00f3n de pedido al usuario.</li> <li>El Servicio de Email env\u00eda el correo de confirmaci\u00f3n al usuario.</li> </ul> </li> <li> <p>Finalizaci\u00f3n</p> <ul> <li>La <code>Backend App BookStore</code> env\u00eda una respuesta al cliente web con el estado de la transacci\u00f3n (\u00e9xito o fallo).</li> </ul> </li> </ol>"},{"location":"bookstore-webapp/","title":"FrontEnd WebApp","text":""},{"location":"bookstore-webapp/#introduccion-al-frontend-con-thymeleaf","title":"Introducci\u00f3n al Frontend con Thymeleaf","text":"<p>En esta secci\u00f3n, abordaremos la creaci\u00f3n de la capa visual de nuestra aplicaci\u00f3n BookStore. Utilizaremos Thymeleaf, un motor de plantillas para Java, que se integra perfectamente con Spring Boot para renderizar vistas en el servidor. Thymeleaf es una opci\u00f3n popular para la construcci\u00f3n de aplicaciones web debido a su simplicidad, eficacia y facilidad de integraci\u00f3n con el ecosistema Spring.</p>"},{"location":"bookstore-webapp/#objetivo","title":"Objetivo","text":"<p>El objetivo de esta secci\u00f3n es proporcionar una gu\u00eda detallada para construir el frontend de la aplicaci\u00f3n BookStore, que incluye:</p> <ul> <li>Visualizaci\u00f3n de libros: Listar los libros disponibles y permitir a los usuarios a\u00f1adirlos a su carrito.</li> <li>Gesti\u00f3n del carrito de compras: Mostrar los \u00edtems del carrito y permitir a los usuarios gestionar su contenido.</li> <li>Proceso de pago: Integrar PayPal para permitir a los usuarios realizar pagos de manera segura.</li> <li>Gesti\u00f3n de \u00f3rdenes: Visualizar las \u00f3rdenes realizadas por los usuarios y permitir la descarga de libros en formato PDF.</li> <li>Confirmaci\u00f3n de pedidos: Mostrar una p\u00e1gina de confirmaci\u00f3n despu\u00e9s de que un pedido se haya completado con \u00e9xito.</li> </ul> <p>Utilizaremos <code>Thymeleaf</code> para crear las vistas y <code>Alpine.js</code> para manejar la interactividad del lado del cliente. Esta combinaci\u00f3n nos permitir\u00e1 construir una interfaz de usuario fluida y din\u00e1mica que mejora la experiencia del usuario.</p> <p>A continuaci\u00f3n, detallamos c\u00f3mo construir cada componente del frontend de nuestra aplicaci\u00f3n, desde la estructura general hasta la integraci\u00f3n con PayPal.</p>"},{"location":"bookstore-webapp/#estructura-general-del-frontend","title":"Estructura General del Frontend","text":"<p>Comenzamos definiendo la estructura general de nuestra aplicaci\u00f3n en el archivo layout.html, que servir\u00e1 como plantilla base para nuestras p\u00e1ginas.</p>"},{"location":"bookstore-webapp/#1-layout","title":"1. Layout","text":"<p>El archivo <code>layout.html</code> define la estructura general de la aplicaci\u00f3n, incluyendo la barra de navegaci\u00f3n y la integraci\u00f3n de estilos y scripts.</p> layout.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"&gt;\n&lt;head&gt;\n    &lt;meta charset=\"utf-8\"/&gt;\n    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"/&gt;\n    &lt;title&gt;BookStore&lt;/title&gt;\n    &lt;meta content=\"width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no\" name=\"viewport\"/&gt;\n    &lt;link rel=\"stylesheet\" href=\"/webjars/bootstrap/5.3.3/css/bootstrap.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"/webjars/font-awesome/6.5.1/css/all.css\"&gt;\n    &lt;link rel=\"stylesheet\" href=\"/css/styles.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;main&gt;\n    &lt;nav class=\"navbar fixed-top navbar-expand-lg navbar-dark bg-dark\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;a class=\"navbar-brand\" href=\"#\" th:href=\"@{/}\"&gt;\n                &lt;img src=\"/images/books.png\" alt=\"Books Logo\" width=\"40\" height=\"40\"&gt; BookStore\n            &lt;/a&gt;\n            &lt;button class=\"navbar-toggler\" type=\"button\" data-bs-toggle=\"collapse\"\n                    data-bs-target=\"#navbarSupportedContent\"\n                    aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\"\n                    aria-label=\"Toggle navigation\"&gt;\n                &lt;span class=\"navbar-toggler-icon\"&gt;&lt;/span&gt;\n            &lt;/button&gt;\n            &lt;div class=\"collapse navbar-collapse\" id=\"navbarSupportedContent\"&gt;\n                &lt;ul class=\"navbar-nav ms-auto mb-2 mb-lg-0\"&gt;\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/orders\" th:href=\"@{/orders}\"&gt;\n                            Orders\n                        &lt;/a&gt;\n                    &lt;/li&gt;\n                    &lt;li class=\"nav-item\"&gt;\n                        &lt;a class=\"nav-link\" href=\"/cart\" th:href=\"@{/cart}\"&gt;\n                            Cart &lt;span id=\"cart-item-count\"&gt;(0)&lt;/span&gt;\n                        &lt;/a&gt;\n                    &lt;/li&gt;\n                &lt;/ul&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/nav&gt;\n\n    &lt;div id=\"app\" class=\"container\"&gt;\n        &lt;div layout:fragment=\"content\"&gt;\n            &lt;!-- Your Page Content Here --&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/main&gt;\n\n&lt;script src=\"/webjars/jquery/3.7.1/jquery.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/webjars/bootstrap/5.3.3/js/bootstrap.bundle.js\"&gt;&lt;/script&gt;\n&lt;script defer src=\"/webjars/alpinejs/3.13.5/dist/cdn.min.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/js/cartStore.js\"&gt;&lt;/script&gt; \n&lt;div layout:fragment=\"pageScripts\"&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"bookstore-webapp/#templates","title":"Templates","text":"<p>A continuaci\u00f3n se describen los templates y su funcionalidad:</p>"},{"location":"bookstore-webapp/#pagination","title":"Pagination","text":"<p>El archivo pagination.html gestiona la paginaci\u00f3n de libros.</p> pagination.html<pre><code>&lt;div th:fragment=\"pagination\"&gt;\n    &lt;template x-if=\"books.totalPages &gt; 1\"&gt;\n        &lt;nav aria-label=\"Page navigation\" &gt;\n            &lt;ul class=\"pagination pagination justify-content-center\"&gt;\n                &lt;li class=\"page-item\" :class=\"{ 'disabled': books.isFirst }\"&gt;\n                    &lt;a class=\"page-link\" href=\"#\" th:href=\"${'/books?page=1'}\"&gt;First&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"page-item\" :class=\"{ 'disabled': !books.hasPrevious }\"&gt;\n                    &lt;a class=\"page-link\" href=\"#\"\n                       :href=\"'/books?page=' + (books.pageNumber-1)\"&gt;Previous&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"page-item\" :class=\"{ 'disabled': !books.hasNext }\"&gt;\n                    &lt;a class=\"page-link\" href=\"#\"\n                       :href=\"'/books?page=' + (books.pageNumber+1)\"&gt;Next&lt;/a&gt;\n                &lt;/li&gt;\n                &lt;li class=\"page-item\" :class=\"{ 'disabled': books.isLast }\"&gt;\n                    &lt;a class=\"page-link\" href=\"#\"\n                       :href=\"'/books?page=' + (books.totalPages)\"&gt;Last&lt;/a&gt;\n                &lt;/li&gt;\n            &lt;/ul&gt;\n        &lt;/nav&gt;\n    &lt;/template&gt;\n&lt;/div&gt;\n</code></pre> <ul> <li>template x-if=\"books.totalPages &gt; 1\": Muestra la paginaci\u00f3n solo si hay m\u00e1s de una p\u00e1gina de libros.</li> <li>li.page-item: Elementos de paginaci\u00f3n para navegar entre las p\u00e1ginas de libros.</li> </ul>"},{"location":"bookstore-webapp/#books","title":"Books","text":"<p>El archivo <code>books.html</code> muestra la lista de libros y permite a\u00f1adirlos al carrito.</p> books.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n      layout:decorate=\"~{layout}\"&gt;\n&lt;body&gt;\n&lt;div layout:fragment=\"content\"&gt;\n    &lt;div th:x-data=\"|initData('${pageNo}')|\"&gt;\n        &lt;div th:replace=\"~{fragments/pagination :: pagination}\"&gt; &lt;/div&gt;\n        &lt;div class=\"row row-cols-1 row-cols-md-5\"&gt;\n            &lt;template x-for=\"book in books.data\"&gt;\n                &lt;div class=\"col mb-3\"&gt;\n                    &lt;div class=\"card h-100 book\"&gt;\n\n                        &lt;img :src=\"'/api/files/' + book.imageUrl\"\n                                class=\"card-img-top\"\n                                height=\"300\" width=\"200\"\n                        /&gt;\n                        &lt;div class=\"card-body\"&gt;\n                            &lt;h5 class=\"card-title\"\n                                data-toggle=\"tooltip\"\n                                data-placement=\"top\"\n                                x-text=\"book.name\"&gt;book.name&lt;/h5&gt;\n                            &lt;p class=\"card-text\"\n                               data-toggle=\"tooltip\"\n                               data-placement=\"top\"\n                               x-text=\"'Price: $'+book.price\"\n                            &gt;book.price&lt;/p&gt;\n                        &lt;/div&gt;\n                        &lt;div class=\"card-footer\" style=\"background: transparent; border-top: 0;\"&gt;\n                            &lt;div class=\"d-grid gap-2\"&gt;\n                                &lt;button class=\"btn btn-primary\" @click=\"addToCart(book)\"&gt;\n                                    Add to Cart\n                                &lt;/button&gt;\n                            &lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/template&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div layout:fragment=\"pageScripts\"&gt;\n    &lt;script src=\"/js/books.js\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>template x-for=\"book in books.data\": Itera sobre la lista de libros y los muestra en tarjetas.</li> <li>button @click=\"addToCart(book)\": A\u00f1ade el libro al carrito cuando se hace clic en el bot\u00f3n.</li> </ul>"},{"location":"bookstore-webapp/#cart","title":"Cart","text":"<p>El archivo <code>cart.html</code> muestra los \u00edtems del carrito y permite proceder al pago con PayPal.</p> cart.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n      layout:decorate=\"~{layout}\"&gt;\n&lt;body&gt;\n&lt;div layout:fragment=\"content\"&gt;\n    &lt;div x-data=\"initData()\"&gt;\n        &lt;div class=\"container\"&gt;\n            &lt;div class=\"row\"&gt;\n                &lt;div class=\"col-md-8\"&gt;\n                    &lt;h2&gt;\u00cdtems del carrito&lt;/h2&gt;\n                    &lt;div x-show=\"cart.items.length == 0\"&gt;\n                        &lt;h3&gt;Tu carrito est\u00e1 vac\u00edo. &lt;a href=\"/\"&gt;Seguir comprando&lt;/a&gt;&lt;/h3&gt;\n                    &lt;/div&gt;\n                    &lt;div x-show=\"cart.items.length &gt; 0\"&gt;\n                        &lt;div class=\"list-group\"&gt;\n                            &lt;template x-for=\"item in cart.items\" :key=\"item.code\"&gt;\n                                &lt;div class=\"list-group-item d-flex justify-content-between align-items-center\"&gt;\n                                    &lt;div class=\"d-flex align-items-center\"&gt;\n                                        &lt;img :src=\"'/api/files/' + item.imageUrl\" alt=\"book image\" width=\"50\" height=\"50\" class=\"mr-3\"&gt;\n                                        &lt;div&gt;\n                                            &lt;h5 x-text=\"item.name\" class=\"mb-1\"&gt;&lt;/h5&gt;\n                                            &lt;small x-text=\"'$' + item.price\"&gt;&lt;/small&gt;\n                                        &lt;/div&gt;\n                                    &lt;/div&gt;\n                                    &lt;div&gt;\n                                        &lt;button class=\"btn btn-danger btn-sm\" @click=\"removeItem(item.id)\"&gt;Eliminar&lt;/button&gt;\n                                    &lt;/div&gt;\n                                &lt;/div&gt;\n                            &lt;/template&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n                &lt;div class=\"col-md-4\"&gt;\n                    &lt;h2&gt;Resumen&lt;/h2&gt;\n                    &lt;div class=\"card\"&gt;\n                        &lt;div class=\"card-body\"&gt;\n                            &lt;h4&gt;Total&lt;/h4&gt;\n                            &lt;h3 x-text=\"'$' + cart.totalAmount\" class=\"text-danger\"&gt;&lt;/h3&gt;\n                            &lt;form @submit.prevent=\"createOrder\"&gt;\n                                &lt;button type=\"submit\" class=\"btn btn-primary btn-block\" :disabled=\"cart.items.length === 0\"&gt;Pagar con PayPal&lt;/button&gt;\n                            &lt;/form&gt;\n                            &lt;a href=\"/\" class=\"btn btn-secondary btn-block mt-2\"&gt;Seguir comprando&lt;/a&gt;\n                        &lt;/div&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div layout:fragment=\"pageScripts\"&gt;\n    &lt;script src=\"https://cdn.jsdelivr.net/npm/alpinejs@2.x.x/dist/alpine.min.js\" defer&gt;&lt;/script&gt;\n    &lt;script src=\"/js/cart.js\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>template x-for=\"item in cart.items\": Itera sobre los \u00edtems del carrito y los muestra en una lista.</li> <li>button @click=\"removeItem(item.id)\": Elimina un \u00edtem del carrito.</li> <li>form @submit.prevent=\"createOrder\": Crea una orden de compra y redirige a PayPal cuando se hace clic en el bot\u00f3n de pago.</li> </ul>"},{"location":"bookstore-webapp/#order","title":"Order","text":"<p>El archivo <code>order.html</code> muestra todas las \u00f3rdenes del usuario.</p> order.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n      layout:decorate=\"~{layout}\" xmlns:x-bind=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;body&gt;\n&lt;div layout:fragment=\"content\"&gt;\n    &lt;div x-data=\"initData()\"&gt;\n        &lt;h2&gt;All Orders&lt;/h2&gt;\n        &lt;hr/&gt;\n        &lt;div class=\"pb-3\"&gt;\n            &lt;table class=\"table\"&gt;\n                &lt;thead&gt;\n                &lt;tr&gt;\n                    &lt;th scope=\"col\"&gt;Order ID&lt;/th&gt;\n                    &lt;th scope=\"col\"&gt;Status&lt;/th&gt;\n                &lt;/tr&gt;\n                &lt;/thead&gt;\n                &lt;tbody&gt;\n                &lt;template x-for=\"order in orders\"&gt;\n                    &lt;tr&gt;\n                        &lt;td&gt;&lt;a x-bind:href=\"'/orders/'+order.orderId\" x-text=\"order.orderId\"&gt;OrderId&lt;/a&gt;&lt;/td&gt;\n                        &lt;td x-text=\"order.paymentStatus\"&gt;paymentStatus&lt;/td&gt;\n                    &lt;/tr&gt;\n                &lt;/template&gt;\n                &lt;/tbody&gt;\n            &lt;/table&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div layout:fragment=\"pageScripts\"&gt;\n    &lt;script src=\"/js/orders.js\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>template x-for=\"order in orders\": Itera sobre las \u00f3rdenes y las muestra en una tabla.</li> <li>a x-bind:href=\"'/orders/'+order.orderId\": Enlace a los detalles de la orden.</li> </ul>"},{"location":"bookstore-webapp/#order-details","title":"Order Details","text":"<p>El archivo <code>order_details.html</code> muestra los detalles de una orden espec\u00edfica.</p> order_details.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n      layout:decorate=\"~{layout}\" xmlns:x-bind=\"http://www.w3.org/1999/xhtml\" xmlns:x-on=\"http://www.w3.org/1999/xhtml\"&gt;\n&lt;body&gt;\n&lt;div layout:fragment=\"content\"&gt;\n    &lt;div th:x-data=\"|initData('${orderNumber}')|\"&gt;\n        &lt;h2&gt;Detalles de la venta&lt;/h2&gt;\n        &lt;div class=\"row\"&gt;\n            &lt;div class=\"col-md-8\"&gt;\n                &lt;h3&gt;\u00cdtems de la venta&lt;/h3&gt;\n                &lt;div class=\"list-group\"&gt;\n                    &lt;template x-for=\"item in orderDetails.items\" :key=\"item.id\"&gt;\n                        &lt;div class=\"list-group-item d-flex justify-content-between align-items-center\"&gt;\n                            &lt;div class=\"row\"&gt;\n                                &lt;div class=\"col-md-4\"&gt;\n                                    &lt;img x-bind:src=\"'/api/files/' + item.imageUrl\"\n                                         class=\"card-img-top\"\n                                         alt=\"Imagen del libro\"\n                                         style=\"width: 100px; height: auto;\"\n                                    /&gt;\n                                &lt;/div&gt;\n                                &lt;div class=\"col-md-8\"&gt;\n                                    &lt;h5 x-text=\"item.bookName\" class=\"mb-1\"&gt;&lt;/h5&gt;\n                                    &lt;p x-text=\"'$' + item.price\"&gt;&lt;/p&gt;\n                                    &lt;p&gt;Descargas Disponibles: &lt;span x-text=\"item.downloadsAvailable\"&gt;&lt;/span&gt;&lt;/p&gt;\n                                &lt;/div&gt;\n                            &lt;/div&gt;\n                            &lt;div&gt;\n                                &lt;a x-bind:href=\"`/orders/${orderDetails.id}/items/${item.id}/book/download`\"\n                                   class=\"btn btn-danger btn-sm\"\n                                   x-on:click.prevent=\"downloadAndUpdateItemDetails(orderDetails.id, item.id)\"\n                                   :class=\"{ 'disabled': item.downloadsAvailable === 0 }\"&gt;\n                                    &lt;i class=\"fa fa-download\"&gt;&lt;/i&gt; Descargar PDF\n                                &lt;/a&gt;\n                            &lt;/div&gt;\n                        &lt;/div&gt;\n                    &lt;/template&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n            &lt;div class=\"col-md-4\"&gt;\n                &lt;h3&gt;Resumen&lt;/h3&gt;\n                &lt;div class=\"card\"&gt;\n                    &lt;div class=\"card-body\"&gt;\n                        &lt;h4&gt;Total&lt;/h4&gt;\n                        &lt;h3 x-text=\"'$' + orderDetails.totalAmount\" class=\"text-danger\"&gt;&lt;/h3&gt;\n                        &lt;a href=\"/\" class=\"btn btn-secondary btn-block mt-2\"&gt;Seguir comprando&lt;/a&gt;\n                    &lt;/div&gt;\n                &lt;/div&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div layout:fragment=\"pageScripts\"&gt;\n    &lt;script src=\"/js/orderDetails.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"/js/cartStore.js\"&gt;&lt;/script&gt;\n&lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>template x-for=\"item in orderDetails.items\": Itera sobre los \u00edtems de la orden y los muestra en una lista.</li> <li>a x-bind:href=\"/orders/${orderDetails.id}/items/${item.id}/book/download\": Enlace para descargar el PDF del libro.</li> </ul>"},{"location":"bookstore-webapp/#confirmation","title":"Confirmation","text":"<p>El archivo <code>confirmation.html</code> muestra la confirmaci\u00f3n del pedido.</p> confirmation.html<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"\n      xmlns=\"http://www.w3.org/1999/xhtml\"\n      xmlns:th=\"http://www.thymeleaf.org\"\n      xmlns:layout=\"http://www.ultraq.net.nz/thymeleaf/layout\"\n      layout:decorate=\"~{layout}\"&gt;\n&lt;body&gt;\n&lt;div layout:fragment=\"content\"&gt;\n    &lt;div class=\"container\"&gt;\n        &lt;h2&gt;Confirmaci\u00f3n de pedido&lt;/h2&gt;\n        &lt;div th:if=\"${completed}\"&gt;\n            &lt;p&gt;El pago se ha realizado correctamente!&lt;/p&gt;\n            &lt;p&gt;Order ID: &lt;span th:text=\"${orderId}\"&gt;&lt;/span&gt;&lt;/p&gt;\n            &lt;a th:href=\"@{/orders/{id}(id=${orderId})}\" class=\"btn btn-primary\"&gt;Ver pedido&lt;/a&gt;\n        &lt;/div&gt;\n        &lt;div th:if=\"${!completed}\"&gt;\n            &lt;p&gt;El pago no se ha realizado correctamente. Por favor, int\u00e9ntelo de nuevo.&lt;/p&gt;\n            &lt;a href=\"/\" class=\"btn btn-secondary\"&gt;Volver a la p\u00e1gina principal&lt;/a&gt;\n        &lt;/div&gt;\n    &lt;/div&gt;\n&lt;/div&gt;\n&lt;div id=\"paymentStatus\" data-completed=\"${completed}\" style=\"display:none;\"&gt;&lt;/div&gt;\n&lt;script src=\"/js/cartStore.js\"&gt;&lt;/script&gt;\n&lt;script src=\"/js/confirmation.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>th:if=\"${completed}\": Muestra el mensaje de confirmaci\u00f3n si el pago se ha completado.</li> <li>th:if=\"${!completed}\": Muestra el mensaje de error si el pago no se ha completado.</li> </ul>"},{"location":"bookstore-webapp/#2-archivos-css","title":"2. Archivos CSS","text":"<p>El archivo styles.css define algunos estilos b\u00e1sicos para nuestra aplicaci\u00f3n.</p> css.xml<pre><code>  #app {\n    padding-top: 90px;\n}\n\n.disabled {\n    pointer-events: none;\n    cursor: default;\n    opacity: 0.5;\n}\n</code></pre> <ul> <li><code>#app</code>: A\u00f1ade un relleno superior de 90 p\u00edxeles al elemento con el ID <code>app</code>.</li> <li><code>.disabled</code>: Aplica un estilo a los elementos deshabilitados, haci\u00e9ndolos no interactivos (<code>pointer-events: none</code>), cambiando el cursor a <code>default</code> y reduciendo la opacidad al 50%.</li> </ul>"},{"location":"bookstore-webapp/#3-archivos-javascript","title":"3. Archivos JavaScript","text":""},{"location":"bookstore-webapp/#booksjs","title":"Books.js","text":"<p>Este script carga los libros y permite a\u00f1adirlos al carrito.</p> books.js<pre><code>document.addEventListener('alpine:init', () =&gt; {\n    Alpine.data('initData', (pageNo) =&gt; ({\n        pageNo: pageNo,\n        books: {\n            data: []\n        },\n        init() {\n            this.loadBooks(this.pageNo);\n            updateCartItemCount();\n        },\n        loadBooks(pageNo) {\n            $.getJSON(\"/api/books?page=\"+pageNo, (resp)=&gt; {\n                console.log(\"Books Resp:\", resp)\n                this.books = resp;\n            });\n        },\n        addToCart(book) {\n            addProductToCart(book)\n        }\n    }))\n});\n</code></pre> <ul> <li>init(): Inicializa los datos cargando los libros de la p\u00e1gina actual y actualizando el contador del carrito.</li> <li>loadBooks(pageNo): Carga los libros de la p\u00e1gina especificada y actualiza el estado books.</li> <li>addToCart(book): A\u00f1ade un libro al carrito.</li> </ul>"},{"location":"bookstore-webapp/#cartjs","title":"Cart.js","text":"<p>Este script gestiona el carrito de compras y el proceso de pago.</p> cart.js<pre><code>document.addEventListener('alpine:init', () =&gt; {\n    Alpine.data('initData', () =&gt; ({\n        cart: { items: [], totalAmount: 0 },\n        user: {\n            firstName: \"Geovanny\",\n            lastName: \"Mendoza\",\n            fullName: \"Geovanny Manuel Mendoza Gonzalez\",\n            email: \"geovanny@gmail.com\",\n            phone: \"999999999999\"\n        },\n        returnUrl: window.location.origin + \"/checkout/paypal/capture\",\n        init() {\n            updateCartItemCount();\n            this.loadCart();\n            this.cart.totalAmount = getCartTotal();\n        },\n        loadCart() {\n            this.cart = getCart()\n        },\n        updateCart() {\n            this.loadCart();\n            this.cart.totalAmount = getCartTotal();\n            updateCartItemCount();\n        },\n        removeItem(id) {\n            removeItemFromCart(id);\n            this.updateCart();\n        },\n        removeCart() {\n            deleteCart();\n        },\n        createOrder() {\n            let createOrderRequest = {\n                customerId: 1,\n                bookIds: this.cart.items.map(item =&gt; Number(item.id))\n            };\n            const url = `/checkout/paypal/create?returnUrl=${encodeURIComponent(this.returnUrl)}`;\n            $.ajax({\n                url: url,\n                type: \"POST\",\n                dataType: \"json\",\n                contentType: \"application/json\",\n                data: JSON.stringify(createOrderRequest),\n                success: (resp) =&gt; {\n                    const approveUrl = resp.approveUrl;\n                    if (approveUrl) { // Cambio importante\n                        this.removeCart();\n                        window.location.href = approveUrl;\n                    } else {\n                        console.error(\"approveUrl is not defined in the response\");\n                        alert(\"Failed to get the approval URL from PayPal\");\n                    }\n                },\n                error: (err) =&gt; {\n                    console.error(\"PayPal Checkout Error:\", err);\n                    alert(\"PayPal checkout failed\");\n                }\n            });\n        }\n    }))\n});\n</code></pre> <ul> <li>init(): Inicializa el carrito cargando sus elementos y actualizando el total.</li> <li>loadCart(): Carga el carrito desde el almacenamiento local.</li> <li>updateCart(): Actualiza el carrito y su total.</li> <li>removeItem(id): Elimina un elemento del carrito.</li> <li>removeCart(): Elimina todos los elementos del carrito.</li> <li>createOrder(): Crea una orden de compra y redirige al usuario a PayPal para completar el pago.</li> </ul>"},{"location":"bookstore-webapp/#cartstorejs","title":"CartStore.js","text":"<p>Este script maneja el almacenamiento del carrito en el localStorage del navegador.</p> cartStore.js<pre><code>const BOOKSTORE_STATE_KEY = \"BOOKSTORE_STATE\";\n\nconst getCart = function() {\n    let cart = localStorage.getItem(BOOKSTORE_STATE_KEY)\n    if (!cart) {\n        cart = JSON.stringify({items:[], totalAmount:0 });\n        localStorage.setItem(BOOKSTORE_STATE_KEY, cart)\n    }\n    return JSON.parse(cart)\n}\n\nconst addProductToCart = function(book) {\n    let cart = getCart();\n    let cartItem = cart.items.find(itemModel =&gt; itemModel.id === book.id);\n    if (cartItem) {\n        cartItem.quantity = parseInt(cartItem.quantity) + 1;\n    } else {\n        cart.items.push(Object.assign({}, book, {quantity: 1}));\n    }\n    localStorage.setItem(BOOKSTORE_STATE_KEY, JSON.stringify(cart));\n    updateCartItemCount();\n}\n\nfunction updateCartItemCount() {\n    let cart = getCart();\n    let count = 0;\n    cart.items.forEach(item =&gt; {\n        count = count + item.quantity;\n    });\n    $('#cart-item-count').text('(' + count + ')');\n}\n\nfunction getCartTotal() {\n    let cart = getCart();\n    let totalAmount = 0;\n    cart.items.forEach(item =&gt; {\n        totalAmount = totalAmount + (item.price * item.quantity);\n    });\n    return totalAmount;\n}\n\nconst removeItemFromCart = function(id) {\n    let cart = getCart();\n    const index = cart.items.findIndex(item =&gt; item.id === id);\n    if (index !== -1) {\n        cart.items.splice(index, 1);\n        localStorage.setItem(BOOKSTORE_STATE_KEY, JSON.stringify(cart));\n        updateCartItemCount();\n    }\n}\n\nconst deleteCart = function() {\n    localStorage.removeItem(BOOKSTORE_STATE_KEY)\n    updateCartItemCount();\n}\n\nfunction clearCart() {\n    localStorage.removeItem(BOOKSTORE_STATE_KEY);\n    updateCartItemCount();\n}\n\ndocument.addEventListener('DOMContentLoaded', function() {\n    updateCartItemCount();\n});\n</code></pre> <ul> <li>getCart(): Obtiene el carrito del localStorage.</li> <li>addProductToCart(book): A\u00f1ade un producto al carrito.</li> <li>updateCartItemCount(): Actualiza el contador de elementos del carrito.</li> <li>getCartTotal(): Calcula el total del carrito.</li> <li>removeItemFromCart(id): Elimina un elemento del carrito.</li> <li>deleteCart(): Elimina todo el carrito.</li> </ul>"},{"location":"bookstore-webapp/#orderjs","title":"Order.js","text":"<p>Este script carga las \u00f3rdenes del usuario.</p> order.js<pre><code>document.addEventListener('alpine:init', () =&gt; {\n    Alpine.data('initData', () =&gt; ({\n        orders: [],\n        init() {\n            this.loadOrders();\n            updateCartItemCount();\n        },\n        loadOrders() {\n            $.getJSON(\"/api/orders\", (data) =&gt; {\n                this.orders = data.map(order =&gt; ({\n                    orderId: order.items[0].orderId, \n                    paymentStatus: order.paymentStatus\n                }));\n            });\n        }\n    }));\n});\n</code></pre> <ul> <li>init(): Inicializa las \u00f3rdenes carg\u00e1ndolas desde el servidor.</li> <li>loadOrders(): Carga las \u00f3rdenes desde el servidor y actualiza el estado orders.</li> </ul>"},{"location":"bookstore-webapp/#orderdetailsjs","title":"OrderDetails.js","text":"<p>Este script carga los detalles de una orden espec\u00edfica.</p> orderDetails.js<pre><code>document.addEventListener('alpine:init', () =&gt; {\n    Alpine.data('initData', (orderNumber) =&gt; ({\n        orderNumber: orderNumber,\n        orderDetails: {\n            items: [],\n            customer: {},\n            deliveryAddress: {},\n            id: orderNumber,\n            totalAmount: 0\n        },\n        init() {\n            updateCartItemCount();\n            this.getOrderDetails(this.orderNumber);\n        },\n        getOrderDetails(orderNumber) {\n            $.getJSON(`/api/orders/${orderNumber}`, (data) =&gt; {\n                this.orderDetails = data;\n                this.orderDetails.id = orderNumber;\n                this.orderDetails.totalAmount = data.total;\n            });\n        },\n        updateItemDetails(orderId, itemId) {\n            $.getJSON(`/api/orders/${orderId}/items/${itemId}`, (data) =&gt; {\n                let itemIndex = this.orderDetails.items.findIndex(item =&gt; item.id === itemId);\n                if(itemIndex !== -1) {\n                    this.orderDetails.items[itemIndex] = data;\n                    this.orderDetails.items[itemIndex].imageUrl = data.imageUrl;\n                    this.$nextTick(() =&gt; {\n                        this.$refresh();\n                    });\n                }\n            });\n        },\n        downloadAndUpdateItemDetails(orderId, itemId) {\n            const downloadLink = `/orders/${orderId}/items/${itemId}/book/download`;\n            window.open(downloadLink, '_blank');\n            setTimeout(() =&gt; {\n                this.updateItemDetails(orderId, itemId);\n            }, 1000);\n        }\n    }));\n});\n</code></pre> <ul> <li>init(): Inicializa los detalles de la orden carg\u00e1ndolos desde el servidor.</li> <li>getOrderDetails(orderNumber): Obtiene los detalles de la orden especificada.</li> <li>updateItemDetails(orderId, itemId): Actualiza los detalles de un \u00edtem en la orden.</li> <li>downloadAndUpdateItemDetails(orderId, itemId): Descarga y actualiza los detalles del \u00edtem.</li> </ul>"},{"location":"bookstore-webapp/#confirmationjs","title":"Confirmation.js","text":"<p>Este script maneja la confirmaci\u00f3n de pago y limpia el carrito despu\u00e9s de una compra exitosa.</p> confirmation.js<pre><code>document.addEventListener('DOMContentLoaded', function() {\n    var completedElement = document.getElementById('paymentStatus');\n    if (completedElement) {\n        var completed = completedElement.getAttribute('data-completed') === 'true';\n        clearCart();\n        if (completed) {\n            localStorage.setItem('paymentCompleted', 'true');\n        }\n    }\n});\n</code></pre>"},{"location":"bookstore-webapp/#conclusion","title":"Conclusi\u00f3n","text":"<p>En esta secci\u00f3n, hemos detallado c\u00f3mo integrar el frontend de la aplicaci\u00f3n BookStore utilizando Thymeleaf para el renderizado de vistas en una aplicaci\u00f3n Spring Boot. Hemos explicado los diferentes templates y scripts que permiten gestionar la visualizaci\u00f3n de libros, el carrito de compras, las \u00f3rdenes y la confirmaci\u00f3n de pedidos, as\u00ed como la integraci\u00f3n con PayPal para el proceso de pago. Con estas herramientas y conocimientos, puedes construir una interfaz de usuario robusta y funcional para tu aplicaci\u00f3n de BookStore.</p>"},{"location":"cache-redis/","title":"Cache con Redis","text":""},{"location":"cache-redis/#uso-de-spring-cache-con-redis","title":"Uso de Spring Cache con Redis","text":"<p>Mejora el rendimiento de tu aplicaci\u00f3n utilizando Spring Cache con Redis:</p> <ul> <li>Uso de Spring Cache.</li> <li>Integraci\u00f3n de spring cache con redis.</li> <li>Creaci\u00f3n de Servidor redis con docker.</li> <li>Programar tareas calendariazadas con spring  </li> </ul> <p></p> <p>Se desea adicionar un cache con redis para todos los libros, el cual deber\u00e1 ser limpiado todos los d\u00edas a las 12:AM. Se debe crear una clave para caache con el nombre users.</p> <p></p>"},{"location":"cache-redis/#implementacion-de-cache-en-spring-boot-con-redis","title":"Implementaci\u00f3n de cach\u00e9 en Spring Boot con Redis","text":"<p>Implementar cach\u00e9 en una aplicaci\u00f3n de Spring Boot usando Redis </p> <p>En el entorno digital acelerado de hoy en d\u00eda, donde la velocidad de la aplicaci\u00f3n es crucial para mejorar la experiencia del usuario, el cach\u00e9 se convierte en un m\u00e9todo potente para aumentar sustancialmente el rendimiento de la aplicaci\u00f3n.</p> <p>En este taller, profundizaremos en el mundo del cach\u00e9 y exploraremos c\u00f3mo implementar el cach\u00e9 de Redis en una aplicaci\u00f3n de Spring Boot, desbloqueando su m\u00e1ximo potencial para producir ventajas de rendimiento significativas.</p>"},{"location":"cache-redis/#proveedores-de-cache-de-spring-boot","title":"Proveedores de cach\u00e9 de Spring Boot","text":"<p>Los proveedores de cach\u00e9 nos permiten configurar el cach\u00e9 en la aplicaci\u00f3n de manera transparente y clara. Utiliza los siguientes pasos para configurar cualquier proveedor de cach\u00e9 dado:</p> <ul> <li>A\u00f1adir la anotaci\u00f3n @EnableCaching al archivo de configuraci\u00f3n.</li> <li>Agregar la biblioteca de cach\u00e9 requerida al classpath.</li> <li>Agregar el archivo de configuraci\u00f3n del proveedor de cach\u00e9 al classpath ra\u00edz.</li> </ul> <p>Los siguientes son los proveedores de cach\u00e9 soportados por el framework de Spring Boot:</p> <ul> <li>JCache</li> <li>EhCache</li> <li>Hazelcast</li> <li>Infinispan</li> <li>Couchbase</li> <li>Redis</li> <li>Caffeine</li> <li>Simple</li> </ul> <p>Redis es una base de datos NoSQL, por lo que no tiene tablas, filas o columnas. Adem\u00e1s, no permite declaraciones como select, insert, update o delete. En su lugar, Redis utiliza estructuras de datos para almacenar datos. Como resultado, puede servir elementos solicitados con frecuencia en tiempos de respuesta de submilisegundos y permitir un escalado f\u00e1cil para cargas de trabajo m\u00e1s grandes sin aumentar el costo de un sistema back-end m\u00e1s caro. Redis tambi\u00e9n puede usarse con soluciones de transmisi\u00f3n para consumir, procesar y analizar datos en tiempo real con latencia de submilisegundos. Por lo tanto, abogamos por implementar el cach\u00e9 en Spring Boot usando Redis.</p>"},{"location":"cache-redis/#que-es-redis","title":"\u00bfQu\u00e9 es Redis?","text":"<p>Remote Dictionary Server, tambi\u00e9n conocido como Redis, es un almac\u00e9n de datos en memoria y una de las muchas opciones para implementar cach\u00e9 en aplicaciones de Spring Boot debido a su velocidad, versatilidad y simplicidad de uso. Es un almac\u00e9n de clave-valor vers\u00e1til que soporta varias estructuras de datos, como Strings, Sorted Sets, Hashes, Lists, Streams, Bitmaps, Sets, etc., ya que es una base de datos NoSQL y no necesita un esquema predeterminado.</p> <p>Redis puede usarse de varias maneras, incluyendo:</p> <ol> <li>Base de Datos en Memoria: En el mundo actual impulsado por los datos, manejar grandes cantidades de datos en tiempo real es un desaf\u00edo com\u00fan para las empresas. Una base de datos en tiempo real es un tipo de repositorio de datos dise\u00f1ado para adquirir, analizar y/o aumentar una corriente entrante de puntos de datos en tiempo real, a menudo inmediatamente despu\u00e9s de que se producen los datos. Redis puede usarse para construir infraestructura de datos para aplicaciones en tiempo real que necesitan alto rendimiento y baja latencia.</li> <li>Cach\u00e9: Muchas aplicaciones luchan con la necesidad de almacenar y recuperar datos r\u00e1pidamente, especialmente en sistemas con alta latencia. Debido a su velocidad, Redis es la opci\u00f3n ideal para el almacenamiento en cach\u00e9 de llamadas a API, estados de sesi\u00f3n, c\u00e1lculos complejos y consultas a bases de datos.</li> <li>Intermediario de Mensajes (MQ): Siempre ha sido dif\u00edcil transmitir datos dentro de la organizaci\u00f3n y hacerlos accesibles para varios componentes del sistema. Redis soporta mensajer\u00eda, fuentes de eventos, alertas y recepci\u00f3n de datos a alta velocidad utilizando su tipo de datos de stream.</li> </ol>"},{"location":"cache-redis/#como-funciona-el-cache-de-redis","title":"\u00bfC\u00f3mo funciona el cach\u00e9 de Redis?","text":"<p>El cach\u00e9 de Redis almacena eficazmente los resultados de las operaciones de recuperaci\u00f3n de bases de datos, permitiendo que las solicitudes posteriores recuperen los datos directamente del cach\u00e9. Esto mejora significativamente el rendimiento de la aplicaci\u00f3n al reducir las llamadas innecesarias a la base de datos.</p> <p></p> <p>C\u00f3mo funciona el cach\u00e9 Cuando se realiza una solicitud, el servicio inicialmente busca en el cach\u00e9 de Redis los datos deseados. Cuando ocurre un acierto de cach\u00e9, los datos se recuperan r\u00e1pidamente del cach\u00e9 y se proporcionan de inmediato al servicio, evitando la necesidad de interactuar con la base de datos.</p> <p>Sin embargo, si los datos solicitados no se encuentran en el cach\u00e9 (falta de cach\u00e9), el servicio recurre inteligentemente a la base de datos para recuperar la informaci\u00f3n requerida. Posteriormente, los datos recuperados se almacenan en el cach\u00e9 de Redis, permitiendo que las futuras solicitudes de los mismos datos se sirvan directamente desde el cach\u00e9, eliminando as\u00ed m\u00e1s consultas a la base de datos y acelerando los tiempos de respuesta en general.</p> <p>Redis tambi\u00e9n puede usarse para tareas de eliminaci\u00f3n y actualizaci\u00f3n, garantizando datos consistentes y actualizados en el cach\u00e9 y mejorando a\u00fan m\u00e1s la eficiencia general.</p>"},{"location":"cache-redis/#configuracion-de-redis-en-un-proyecto-spring-boot","title":"Configuraci\u00f3n de Redis en un Proyecto Spring Boot","text":""},{"location":"cache-redis/#1-configurar-redis-en-docker","title":"1. Configurar Redis en Docker","text":"<p>Archivo <code>dev-stack.yml</code></p> <ul> <li>Este archivo de Docker Compose configura un contenedor de Redis para el entorno de desarrollo.</li> </ul> dev-stack.yaml<pre><code>  cache-db:\n    image: redis:6.2-alpine\n    container_name: best_book_cache\n    restart: always\n    ports:\n      - \"6379:6379\"\n    command: redis-server --loglevel warning --requirepass jconfdominicana\n</code></pre> <ul> <li>image: redis:6.2-alpine: Utiliza la imagen <code>redis</code> versi\u00f3n <code>6.2-alpine</code>.</li> <li>container_name: <code>best_book_cach</code>: Nombre del contenedor.</li> <li>restart: <code>always</code>: Configura el contenedor para que se reinicie autom\u00e1ticamente.</li> <li>ports: <code>\"6379:6379\"</code>: Mapea el puerto <code>6379</code> del host al puerto <code>6379</code> del contenedor.</li> <li>command: <code>redis-server --loglevel warning --requirepass jconfdominicana</code>: Inicia Redis con un nivel de log <code>warning</code> y una contrase\u00f1a <code>jconfdominicana</code>.</li> </ul>"},{"location":"cache-redis/#2-configurar-redis-en-spring-boot","title":"2. Configurar Redis en Spring Boot","text":"<p>Archivo <code>application.properties</code></p> <ul> <li>Configura la conexi\u00f3n a Redis en el archivo de propiedades.</li> </ul> application.properties<pre><code>####### Redis Configuration ########\ncache.redis.address=redis://127.0.0.1:6379\ncache.redis.password=jconfdominicana\n</code></pre> <ul> <li><code>cache.redis.address=redis://127.0.0.1:6379</code>: Direcci\u00f3n del servidor Redis.</li> <li><code>cache.redis.password=jconfdominicana</code>: Contrase\u00f1a para acceder a Redis.</li> </ul>"},{"location":"cache-redis/#3-configuracion-de-propiedades","title":"3. Configuraci\u00f3n de Propiedades","text":"<p>Clase <code>PropertiesConfig.java</code></p> <p>Esta clase carga las propiedades de configuraci\u00f3n.</p> PropertiesConfig.java<pre><code>@Configuration\n@PropertySource(value=\"classpath:application.properties\")\npublic class PropertiesConfig {\n\n}\n</code></pre> <ul> <li><code>@Configuration</code>: Indica que esta clase tiene una o m\u00e1s definiciones de m\u00e9todos <code>@Bean</code>.</li> <li><code>@PropertySource(value=\"classpath:application.properties\")</code>: Carga el archivo <code>application.properties</code>.</li> </ul>"},{"location":"cache-redis/#4-dependencias-en-pomxml","title":"4. Dependencias en <code>pom.xml</code>","text":"<p>Adicionar las dependencias necesarias para Redis.</p> <pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n   &lt;groupId&gt;org.redisson&lt;/groupId&gt;\n   &lt;artifactId&gt;redisson&lt;/artifactId&gt;\n   &lt;version&gt;3.18.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <ul> <li><code>spring-boot-starter-cache</code>: Proporciona soporte para la anotaci\u00f3n de cach\u00e9 de Spring.</li> <li><code>redisson</code>: Cliente Redis avanzado para Java.</li> </ul>"},{"location":"cache-redis/#5-clase-de-constantes","title":"5. Clase de Constantes","text":"<p>Clase <code>CacheConstants.java</code></p> <p>Define constantes utilizadas en la configuraci\u00f3n de cach\u00e9.</p> CacheConstants.java<pre><code>public class CacheConstants {\n    public static final String USER_CACHE_NAME = \"users\";\n    public static final String SCHEDULED_RESET_CACHE = \"0 0 0 * * ?\";\n}\n</code></pre> <ul> <li><code>USER_CACHE_NAME</code>: Nombre del cach\u00e9 para usuarios.</li> <li> <p><code>SCHEDULED_RESET_CACHE</code>: Cron para reiniciar el cach\u00e9 diariamente.</p> </li> <li> <p>Link: Redis Calendario</p> </li> </ul>"},{"location":"cache-redis/#6-configuracion-de-redis","title":"6. Configuraci\u00f3n de Redis","text":"<p>Clase <code>RedisConfig.java</code></p> <p>La clase <code>RedisConfig</code> se encarga de configurar el cliente Redis y el gestor de cach\u00e9 en una aplicaci\u00f3n Spring Boot.</p> RedisConfig.java<pre><code>import lombok.extern.slf4j.Slf4j;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.redisson.spring.cache.CacheConfig;\nimport org.redisson.spring.cache.RedissonSpringCacheManager;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.CacheManager;\nimport org.springframework.cache.annotation.EnableCaching;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.beans.factory.annotation.Value;\n\nimport java.util.Map;\n\n@Configuration\n@EnableCaching\n@Slf4j\npublic class RedisConfig {\n\n    @Value(value = \"${cache.redis.address}\")\n    private String serverAddress; //Server address to redis\n    @Value(value = \"${cache.redis.password}\")\n    private String serverPassword; //Server password\n\n    /*\n     * Con esta configuracion cargamos el cliente de redis al contenedor de spring\n     */\n    @Bean\n    public RedissonClient redissonClient() {\n        var config = new Config();\n        config.useSingleServer()\n                .setAddress(serverAddress)\n                .setPassword(serverPassword);\n        return Redisson.create(config);\n    }\n\n    /*\n     * Con esta configuracion podemos habilitar las anotaciones de spring cache @Cacheable\n     */\n    @Bean\n    @Autowired\n    public CacheManager cacheManager(RedissonClient redissonClient) {\n        var configs = Map.of(\n                CacheConstants.USER_CACHE_NAME, new CacheConfig()\n        );\n        return new RedissonSpringCacheManager(redissonClient, configs);\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 16-18</p> <ul> <li><code>@Configuration</code>: Indica que esta clase tiene una o m\u00e1s definiciones de m\u00e9todos <code>@Bean</code>.</li> <li><code>@EnableCaching</code>: Habilita la anotaci\u00f3n de cach\u00e9 de Spring, permitiendo el uso de anotaciones como <code>@Cacheable</code>, <code>@CacheEvict</code>, etc.</li> <li><code>@Slf4j</code>: Habilita el logging en la clase mediante la biblioteca Lombok.</li> </ul> </li> <li> <p>L\u00ednea 21-24</p> <ul> <li><code>@Value(\"${cache.redis.address}\")</code>: Inyecta el valor de la propiedad cache.redis.address desde application.properties en la variable serverAddress.</li> <li><code>@Value(\"${cache.redis.password}\")</code>: Inyecta el valor de la propiedad cache.redis.password desde application.properties en la variable serverPassword.</li> </ul> </li> <li>L\u00ednea 29-36<ul> <li><code>@Bean</code>: Indica que este m\u00e9todo produce un bean que ser\u00e1 manejado por el contenedor de Spring.</li> <li><code>public RedissonClient redissonClient()</code>: M\u00e9todo que configura y retorna una instancia de RedissonClient.</li> <li><code>Config config = new Config();</code>: Crea una nueva instancia de Config para configurar Redisson.</li> <li><code>config.useSingleServer()</code>: Configura Redisson para usar un \u00fanico servidor Redis.</li> <li><code>setAddress(serverAddress)</code>: Establece la direcci\u00f3n del servidor Redis usando el valor inyectado en serverAddress.</li> <li><code>setPassword(serverPassword)</code>: Establece la contrase\u00f1a del servidor Redis usando el valor inyectado en serverPassword.</li> <li><code>return Redisson.create(config);</code>: Crea y retorna una instancia de RedissonClient utilizando la configuraci\u00f3n especificada.</li> </ul> </li> <li>L\u00ednea 41-48<ul> <li><code>@Bean</code>: Indica que este m\u00e9todo produce un bean que ser\u00e1 manejado por el contenedor de Spring.</li> <li><code>@Autowired</code>: Inyecta autom\u00e1ticamente el RedissonClient en este m\u00e9todo.</li> <li><code>public CacheManager cacheManager(RedissonClient redissonClient)</code>: M\u00e9todo que configura y retorna una instancia de CacheManager.</li> <li><code>Map.of(CacheConstants.USER_CACHE_NAME, new CacheConfig())</code>: Crea un mapa de configuraciones de cach\u00e9, utilizando la constante <code>USER_CACHE_NAME</code> como clave y una nueva instancia de CacheConfig como valor.</li> <li><code>return new RedissonSpringCacheManager(redissonClient, configs);</code>: Crea y retorna una instancia de RedissonSpringCacheManager utilizando el RedissonClient y las configuraciones de cach\u00e9 especificadas.</li> </ul> </li> </ul>"},{"location":"cache-redis/#7-adicionar-cache-en-el-servicio-de-usuarios","title":"7. Adicionar Cach\u00e9 en el Servicio de Usuarios","text":"<p>Clase <code>UserService.java</code></p> <p>Aplica cach\u00e9 a los m\u00e9todos del servicio de usuarios.</p> UserService.java<pre><code>@Service\npublic class UserService {\n\n  @Cacheable(value = CacheConstants.USER_CACHE_NAME)\n    public List&lt;User&gt; getUsers() {\n        try {\n            Thread.sleep(7000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n            return userRepository.findAll().stream()\n                    .map(UserMapper::toUser)\n                    .collect(Collectors.toList());\n    }\n\n    @Cacheable(value = CacheConstants.USER_CACHE_NAME)\n    public Optional&lt;User&gt; getUserById(Long id) {\n        try {\n            Thread.sleep(7000);\n        } catch (InterruptedException e) {\n            throw new RuntimeException(e);\n        }\n        try {\n            return userRepository.findById(id).map(UserMapper::toUser);\n        } catch (Exception e) {\n            throw new UserNotFoundException(\"User not found\");\n        }\n    }\n}\n</code></pre> <ul> <li><code>@Cacheable(value = CacheConstants.USER_CACHE_NAME)</code>: Anotaci\u00f3n que indica que el resultado del m\u00e9todo debe ser almacenado en cach\u00e9.</li> </ul>"},{"location":"cache-redis/#8-limpiar-cache-con-un-metodo-calendarizado","title":"8. Limpiar Cach\u00e9 con un M\u00e9todo Calendarizado","text":"<p>Adici\u00f3n de Anotaciones</p> <ul> <li><code>@EnableScheduling</code>: Habilita la programaci\u00f3n de tareas.</li> </ul> <p>M\u00e9todo <code>deleteCache</code> en <code>RedisConfig.java</code> <pre><code>@CacheEvict(cacheNames ={CacheConstants.USER_CACHE_NAME}, allEntries = true)\n@Scheduled(cron = CacheConstants.SCHEDULED_RESET_CACHE)\n@Async\npublic void deleteCache() {\n    log.info(\"Clean cache\");\n}\n</code></pre></p> <ul> <li><code>@CacheEvict(cacheNames = {CacheConstants.USER_CACHE_NAME}, allEntries = true)</code>: Elimina todas las entradas del cach\u00e9 especificado.</li> <li><code>@Scheduled(cron = CacheConstants.SCHEDULED_RESET_CACHE)</code>: Programa la tarea seg\u00fan la expresi\u00f3n cron.</li> <li><code>@Async</code>: Ejecuta el m\u00e9todo de forma as\u00edncrona.</li> </ul>"},{"location":"cache-redis/#conclusiones","title":"Conclusiones","text":"<p>En esta sesi\u00f3n, hemos configurado Redis para el manejo de cach\u00e9 en una aplicaci\u00f3n Spring Boot, desde la configuraci\u00f3n del contenedor de Redis en Docker, pasando por la configuraci\u00f3n de propiedades y la inyecci\u00f3n de dependencias en Spring, hasta la implementaci\u00f3n del cach\u00e9 en el servicio de usuarios. Esta configuraci\u00f3n mejora significativamente el rendimiento de la aplicaci\u00f3n, asegurando que las respuestas a las solicitudes se sirvan de manera r\u00e1pida y eficiente.</p>"},{"location":"get-book/","title":"Crear Proyecto de Spring","text":"<p>Para empezar, accedemos a Spring initialzr y configuramos el proyecto de la siguiente manera:</p> <ul> <li>Project: Maven</li> <li>Language: Java</li> <li>Spring Boot: 3.+ (la \u00faltima versi\u00f3n estable)</li> <li>Project Metadata:<ul> <li>Group: com.geovannycodfigue</li> <li>Artifact: bookstore</li> <li>Name: bookstore</li> </ul> </li> <li>Packaging: Jar</li> <li>Java: 21</li> </ul>"},{"location":"get-book/#adicionar-dependencias","title":"Adicionar Dependencias","text":"<p>Agregamos las siguientes dependencias en el archivo <code>pom.xml</code>:</p> <p></p>"},{"location":"get-book/#dependencias","title":"Dependencias:","text":"pom.xml<pre><code>    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;\n      &lt;artifactId&gt;flyway-core&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.flywaydb&lt;/groupId&gt;\n      &lt;artifactId&gt;flyway-database-postgresql&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n      &lt;scope&gt;runtime&lt;/scope&gt;\n      &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.postgresql&lt;/groupId&gt;\n      &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n      &lt;scope&gt;runtime&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n      &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n      &lt;optional&gt;true&lt;/optional&gt;\n    &lt;/dependency&gt;\n</code></pre> <p>Una vez configurado el proyecto y a\u00f1adidas las dependencias, generamos el proyecto y descargamos el archivo .zip. Lo descomprimimos y abrimos el proyecto en el IDE IntelliJ IDEA.</p>"},{"location":"get-book/#creacion-docker-componse","title":"Creaci\u00f3n Docker Componse","text":""},{"location":"get-book/#configuracion-del-entorno-de-desarrollo-con-docker-compose","title":"Configuraci\u00f3n del Entorno de Desarrollo con Docker Compose","text":"<p>Para configurar el entorno de desarrollo, vamos a crear un archivo llamado <code>dev-stack.yml</code> que definir\u00e1 los servicios necesarios utilizando Docker Compose. En este ejemplo, configuraremos un contenedor para PostgreSQL.</p> dev-stack.yml<pre><code>name: 'bookstore'\nservices:\n  bookstore-db:\n    image: postgres:16-alpine\n    container_name: bookstore-db\n    environment:\n      - POSTGRES_USER=postgres\n      - POSTGRES_PASSWORD=postgres\n      - POSTGRES_DB=postgres\n    ports:\n      - \"15432:5432\"\n    healthcheck:\n      test: [ \"CMD-SHELL\", \"pg_isready -U postgres\" ]\n      interval: 10s\n      timeout: 5s\n      retries: 5\n    deploy:\n      resources:\n        limits:\n          memory: 500m\n</code></pre> <ul> <li>L\u00ednea 1: <code>name: 'bookstore'</code> Define el nombre del proyecto Docker Compose. Este nombre se usa para agrupar todos los servicios definidos en el archivo bajo un mismo proyecto.</li> <li>L\u00ednea 2: <code>services</code> Aqu\u00ed se definen los servicios que se utilizar\u00e1n en el entorno de desarrollo. En este caso, solo tenemos un servicio llamado bookstore-db.</li> <li>L\u00ednea 4: <code>image: postgres:16-alpine</code> Especifica la imagen de Docker que se utilizar\u00e1 para el contenedor de la base de datos PostgreSQL. En este caso, estamos usando la imagen postgres:16-alpine, que es una versi\u00f3n ligera de PostgreSQL.</li> <li>L\u00ednea 5: container_name: <code>bookstore-db</code> Define el nombre del contenedor.</li> <li>L\u00ednea 6-9: environment: Aqu\u00ed se definen las variables de entorno necesarias para configurar PostgreSQL.<ul> <li>POSTGRES_USER=postgres: El nombre de usuario de PostgreSQL.</li> <li>POSTGRES_PASSWORD=postgres: La contrase\u00f1a del usuario de PostgreSQL.</li> <li>POSTGRES_DB=postgres: El nombre de la base de datos por defecto.</li> </ul> </li> <li>L\u00ednea 10-11: <code>ports</code> Mapea el puerto 5432 del contenedor al puerto 15432 en el host. Esto permite acceder a PostgreSQL en el puerto 15432 de tu m\u00e1quina local.</li> <li>L\u00ednea 12-16: <code>healthcheck</code> Define un chequeo de salud para el contenedor.<ul> <li><code>test: [ \"CMD-SHELL\", \"pg_isready -U postgres\" ]</code>: Comando que se ejecutar\u00e1 para verificar si la base de datos est\u00e1 lista.</li> <li><code>interval: 10s:</code> Intervalo de tiempo entre cada chequeo.</li> <li><code>timeout: 5s:</code> Tiempo m\u00e1ximo que se espera una respuesta antes de considerar el chequeo como fallido.</li> <li><code>retries: 5:</code> N\u00famero de intentos de chequeo fallidos antes de marcar el contenedor como no saludable.</li> </ul> </li> <li>L\u00ednea 17-20: <code>deploy:</code> Configuraciones de despliegue.<ul> <li><code>resources:</code> Limita los recursos del contenedor.</li> <li><code>limits:</code> Limita la cantidad de memoria que puede usar el contenedor.</li> <li><code>memory:</code> 500m: L\u00edmite de memoria establecido en 500MB.</li> </ul> </li> </ul> <p>Comandos para gestionar Docker Compose Para iniciar y detener la base de datos con Docker Compose, utilizamos los siguientes comandos:</p> <p>Subir la base de datos</p> <pre><code>docker compose -f dev-stack.yml up -d\n</code></pre> <p>Este comando levanta los servicios definidos en <code>dev-stack.yml</code> en modo detached (en segundo plano). La base de datos <code>PostgreSQL</code> se iniciar\u00e1 y estar\u00e1 disponible en el puerto <code>15432</code> de tu m\u00e1quina local.</p> <p>Detener la base de datos</p> <pre><code>docker compose -f dev-stack.yml down\n</code></pre> <p>Este comando detiene y elimina los contenedores, redes y vol\u00famenes definidos en dev-stack.yml.</p>"},{"location":"get-book/#creacion-crud","title":"Creacion CRUD","text":""},{"location":"get-book/#creacion-entidad","title":"Creacion Entidad","text":"<p>Primero, creamos los paquetes necesarios en el proyecto para organizar nuestro c\u00f3digo de manera clara y estructurada. Los paquetes que necesitamos son:</p> <ul> <li><code>model</code></li> <li><code>repository</code></li> <li><code>service</code></li> <li><code>controller</code></li> <li><code>dto</code></li> <li><code>mapper</code></li> </ul>"},{"location":"get-book/#paso-1-crear-la-clase-bookentity","title":"Paso 1: Crear la clase <code>BookEntity</code>","text":"<p>Dentro del paquete <code>model</code>, creamos una clase llamada <code>BookEntity</code> con los siguientes campos: <code>id</code>, <code>code</code>, <code>name</code>, <code>description</code>, <code>price</code>, <code>imageUrl</code>, <code>filePath</code>, <code>createdAt</code>, y <code>updatedAt</code>.</p> BookEntity.java<pre><code>package com.jconfdominicana.bookstore.model;\n\nimport jakarta.persistence.Column;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.Table;\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport lombok.AllArgsConstructor;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Entity\n@Table(name = \"books\")\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\npublic class BookEntity {\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"book_id_generator\")\n    @SequenceGenerator(name = \"book_id_generator\", sequenceName = \"book_id_seq\")\n    private Long id;\n\n    @Column(nullable = false, unique = true)\n    private String code;\n\n    @Column(nullable = false)\n    private String name;\n\n    private String description;\n\n    @Column(nullable = false)\n    private BigDecimal price;\n\n    @Column(name = \"image_url\")\n    private String imageUrl;\n\n    @Column(name = \"file_path\")\n    private String filePath;\n\n    @Column(name = \"created\", nullable = false, updatable = false)\n    private LocalDateTime createdAt = LocalDateTime.now();\n\n    @Column(name = \"modified\")\n    private LocalDateTime updatedAt;\n}\n</code></pre> <ul> <li>L\u00ednea 17: <code>@Entity</code> Indica que esta clase es una entidad de JPA.</li> <li>L\u00ednea 18: <code>@Table(name = \"books\")</code> Especifica la tabla de base de datos con la que se mapear\u00e1 esta entidad.</li> <li>L\u00edneas 19-22:</li> </ul> <pre><code>@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n</code></pre> <ul> <li> <p>Anotaciones de Lombok:</p> <ul> <li>@Getter: Genera autom\u00e1ticamente los m\u00e9todos getter para todos los campos.</li> <li>@Setter: Genera autom\u00e1ticamente los m\u00e9todos setter para todos los campos.</li> <li>@AllArgsConstructor: Genera un constructor con un argumento para cada campo en la clase.</li> <li>@NoArgsConstructor: Genera un constructor sin argumentos.</li> </ul> </li> <li> <p>L\u00edneas 25-27:</p> </li> </ul> <pre><code>@Id\n@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"book_id_generator\")\n@SequenceGenerator(name = \"book_id_generator\", sequenceName = \"book_id_seq\")\nprivate Long id;\n</code></pre> <p>Configura el campo <code>id</code> como la clave primaria.</p> <ul> <li>@Id: Define el campo id como la clave primaria.</li> <li>@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"book_id_generator\"): Especifica que el valor de este campo se generar\u00e1 autom\u00e1ticamente usando una secuencia.</li> <li> <p>@SequenceGenerator(name = \"book_id_generator\", sequenceName = \"book_id_seq\"): Define el generador de secuencia para la clave primaria.</p> </li> <li> <p>L\u00edneas 30-31:</p> </li> </ul> <pre><code>@Column(nullable = false, unique = true)\nprivate String code;\n</code></pre> <p>Configura el campo <code>code</code> como una columna no nula y \u00fanica.</p> <ul> <li>L\u00edneas 33-34:</li> </ul> <pre><code>@Column(nullable = false)\nprivate String name;\n</code></pre> <p>Configura el campo <code>name</code> como una columna no nula.</p> <ul> <li>L\u00edneas 38-39:</li> </ul> <pre><code>@Column(nullable = false)\nprivate BigDecimal price;\n</code></pre> <p>Configura el campo <code>price</code> como una columna no nula.</p> <ul> <li> <p>Nota: En Java, <code>BigDecimal</code> es recomendado sobre <code>double</code> o <code>float</code> para representar valores num\u00e9ricos de precisi\u00f3n arbitraria, especialmente en aplicaciones que requieren una alta precisi\u00f3n en c\u00e1lculos num\u00e9ricos, como es el caso de aplicaciones financieras y de comercio electr\u00f3nico. Ac\u00e1 te explico las razones principales:</p> <ul> <li>Con <code>BigDecimal</code>, puedes realizar operaciones aritm\u00e9ticas (suma, resta, multiplicaci\u00f3n, divisi\u00f3n) con precisi\u00f3n garantizada. En double y float, las operaciones aritm\u00e9ticas pueden resultar en p\u00e9rdida de precisi\u00f3n debido a la naturaleza del almacenamiento en punto flotante.</li> <li>En aplicaciones financieras, los valores monetarios deben ser exactos. Un error de redondeo puede tener consecuencias significativas en c\u00e1lculos de intereses, balances, precios, etc.</li> <li><code>BigDecimal</code> es la elecci\u00f3n natural para estos contextos debido a su capacidad para manejar valores precisos y realizar c\u00e1lculos sin errores de redondeo.</li> </ul> </li> <li> <p>L\u00ednea 41-42:</p> </li> </ul> <pre><code>@Column(name = \"image_url\")\nprivate String imageUrl;\n</code></pre> <p>Configura el campo <code>imageUrl</code> como una columna opcional con un nombre espec\u00edfico en la base de datos.</p> <ul> <li>L\u00ednea 44-45:</li> </ul> <pre><code>@Column(name = \"file_path\")\nprivate String filePath;\n</code></pre> <p>Configura el campo <code>filePath</code> como una columna opcional con un nombre espec\u00edfico en la base de datos.</p> <ul> <li>L\u00edneas 47-48:</li> </ul> <pre><code>@Column(name = \"created\", nullable = false, updatable = false)\nprivate LocalDateTime createdAt = LocalDateTime.now();\n</code></pre> <p>Configura el campo <code>createdAt</code> como una columna no nula que no se puede actualizar, inicializada con la fecha y hora actual.</p> <ul> <li>L\u00edneas 50-51:</li> </ul> <pre><code>@Column(name = \"modified\")\nprivate LocalDateTime updatedAt;\n</code></pre> <p>Configura el campo <code>updatedAt</code> como una columna opcional con un nombre espec\u00edfico en la base de datos.</p>"},{"location":"get-book/#paso-2-validacion-de-la-entidad","title":"Paso 2: Validaci\u00f3n de la Entidad","text":"<p>Para validar el modelo <code>BookEntity</code>, se ha a\u00f1adido la siguiente anotacion de validaci\u00f3n:</p> <ul> <li>@Column: Especifica que el campo es una columna en la base de datos.</li> </ul> <p>Con esta configuraci\u00f3n, la clase <code>BookEntity</code> est\u00e1 lista para ser utilizada como una entidad de base de datos en tu aplicaci\u00f3n Spring Boot.</p>"},{"location":"get-book/#creacion-repositorio","title":"Creacion Repositorio","text":""},{"location":"get-book/#paso-1-crear-el-repositorio-para-la-entidad-bookentity","title":"Paso 1: Crear el Repositorio para la Entidad <code>BookEntity</code>","text":"<p>Dentro del paquete <code>repository</code>, creamos una interfaz llamada <code>BookRepository</code> que hereda de <code>JpaRepository&lt;BookEntity, Long&gt;</code>. A\u00f1adimos un m\u00e9todo personalizado para encontrar un libro por su c\u00f3digo.</p> BookRepository.java<pre><code>package com.jconfdominicana.bookstore.repository;\n\nimport com.jconfdominicana.bookstore.model.BookEntity;\nimport java.util.Optional;\nimport org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface BookRepository extends JpaRepository&lt;BookEntity, Long&gt; {\n    Optional&lt;BookEntity&gt; findByCode(String code);\n}\n</code></pre> <ul> <li>L\u00ednea 5:</li> </ul> <pre><code>import org.springframework.data.jpa.repository.JpaRepository;\n</code></pre> <p>Importa la interfaz JpaRepository de Spring Data JPA.</p> <ul> <li>L\u00ednea 7:</li> </ul> <pre><code>public interface BookRepository extends JpaRepository&lt;BookEntity, Long&gt; {\n</code></pre> <p>Define la interfaz <code>BookRepository</code> que hereda de <code>JpaRepository</code> para proporcionar operaciones CRUD.</p> <ul> <li>L\u00ednea 8:</li> </ul> <pre><code>Optional&lt;BookEntity&gt; findByCode(String code);\n</code></pre> <p>Declara un m\u00e9todo personalizado para encontrar un libro por su c\u00f3digo.</p>"},{"location":"get-book/#que-es-jparepository","title":"\u00bfQu\u00e9 es JpaRepository?","text":"<p><code>JpaRepository</code> es una interfaz de Spring Data JPA que extiende <code>CrudRepository</code> y <code>PagingAndSortingRepository</code>. Proporciona m\u00e9todos adicionales para trabajar con la persistencia de datos de una manera m\u00e1s avanzada y eficiente.</p> <p>Diferencias entre JpaRepository y CrudRepository:</p> <ul> <li>CrudRepository: Proporciona m\u00e9todos CRUD b\u00e1sicos como <code>save</code>, <code>findAll</code>, <code>findById</code>, y <code>delete</code>.</li> <li>JpaRepository: Adem\u00e1s de los m\u00e9todos proporcionados por <code>CrudRepository</code>, incluye m\u00e9todos adicionales para paginaci\u00f3n y ordenaci\u00f3n, como <code>findAll(Pageable pageable)</code> y <code>findAll(Sort sort)</code>. Tambi\u00e9n tiene m\u00e9todos para operaciones en batch y otros m\u00e1s avanzados.</li> </ul> <p>M\u00e9todos Personalizados En algunos casos, necesitamos m\u00e9todos que no est\u00e1n disponibles por defecto en <code>JpaRepository</code>. Para esto, podemos definir m\u00e9todos personalizados en nuestro repositorio.</p> <p>Ejemplo de M\u00e9todo Personalizado:</p> <pre><code>Optional&lt;BookEntity&gt; findByCode(String code);\n</code></pre> <p>Este m\u00e9todo personalizado utiliza la convenci\u00f3n de nomenclatura de Spring Data JPA para generar autom\u00e1ticamente la consulta SQL.</p> <p>Uso de JPQL para Consultas Personalizadas</p> <p>JPQL (Java Persistence Query Language) es una poderosa herramienta para escribir consultas personalizadas en Spring Data JPA. Podemos definir consultas utilizando la anotaci\u00f3n <code>@Query</code>.</p> <p>Ejemplo de Uso de JPQL:</p> <pre><code>import org.springframework.data.jpa.repository.Query;\n\n@Query(\"SELECT b FROM BookEntity b WHERE b.code = :code\")\nOptional&lt;BookEntity&gt; findByCodeJPQL(@Param(\"code\") String code);\n</code></pre> <p>Esta consulta personalizada selecciona un <code>BookEntity</code> basado en el c\u00f3digo utilizando JPQL.</p>"},{"location":"get-book/#creacion-dto","title":"Creacion DTO","text":"<p>\u00bfQu\u00e9 es un Record en Java? Un record es una nueva clase en Java introducida en la <code>versi\u00f3n 14</code> como una caracter\u00edstica preliminar y estabilizada en la <code>versi\u00f3n 16</code>. Los records est\u00e1n dise\u00f1ados para ser clases inmutables que se utilizan principalmente para contener datos. Proveen una manera concisa de declarar clases de datos, eliminando gran parte del c\u00f3digo repetitivo.</p> <p>Caracter\u00edsticas de los Records:</p> <ul> <li>Inmutabilidad: Los campos de un record son finales por defecto. Esto significa que no se pueden cambiar una vez que se establece su valor. Es decir, una vez que se crea un objeto de record con ciertos valores, esos valores no pueden ser modificados. Esto ayuda a mantener la integridad de los datos y evita errores asociados con cambios inesperados.</li> <li>Concisi\u00f3n: Se generan autom\u00e1ticamente m\u00e9todos como <code>equals</code>, <code>hashCode</code>, y <code>toString</code>. Esto reduce la cantidad de c\u00f3digo que el desarrollador necesita escribir, ya que estas implementaciones suelen ser est\u00e1ndar y repetitivas.</li> <li>Utilidad: Facilitan la creaci\u00f3n de clases de datos con menos c\u00f3digo. Los records son especialmente \u00fatiles para definir objetos simples que solo contienen datos, sin l\u00f3gica adicional.</li> </ul>"},{"location":"get-book/#paso-1-crear-el-dto","title":"Paso 1: Crear el DTO","text":"<ul> <li>Dentro del paquete <code>dto</code>, creamos un <code>record</code> Java llamado <code>Book</code> con los campos <code>id</code>, <code>code</code>, <code>name</code>, <code>description</code>, <code>price</code>, <code>imageUrl</code>, y <code>filePath</code> de la entidad <code>BookEntity</code>. A\u00f1adimos validaciones a estos campos.</li> </ul> Book.java<pre><code>package com.jconfdominicana.bookstore.dto;\n\nimport jakarta.validation.constraints.DecimalMin;\nimport jakarta.validation.constraints.NotBlank;\nimport jakarta.validation.constraints.NotEmpty;\nimport jakarta.validation.constraints.NotNull;\nimport java.math.BigDecimal;\n\npublic record Book(\n        String id,\n        @NotEmpty(message = \"Book code is required\") String code,\n        @NotEmpty(message = \"Book name is required\") String name,\n        String description,\n        @NotNull(message = \"Book price is required\") @DecimalMin(\"0.1\") BigDecimal price,\n        @NotBlank String imageUrl,\n        @NotBlank String filePath) {}\n</code></pre> <ul> <li>L\u00ednea 9:</li> </ul> <pre><code>public record Book(\nDefine el record Book que encapsula los datos del libro.\n</code></pre> <ul> <li>L\u00ednea 11:</li> </ul> <pre><code>@NotEmpty(message = \"Book code is required\") String code,\n</code></pre> <p>Define el campo <code>code</code> y a\u00f1ade la validaci\u00f3n <code>@NotEmpty</code>.</p> <ul> <li>L\u00ednea 14:</li> </ul> <pre><code>@NotNull(message = \"Book price is required\") @DecimalMin(\"0.1\") BigDecimal price,\n</code></pre> <p>Define el campo <code>price</code> y a\u00f1ade las validaciones <code>@NotNull</code> y <code>@DecimalMin</code>.</p> <ul> <li>L\u00ednea 15:</li> </ul> <pre><code>@NotBlank String imageUrl,\n</code></pre> <p>Define el campo <code>imageUrl</code> y a\u00f1ade la validaci\u00f3n <code>@NotBlank</code>.</p>"},{"location":"get-book/#paso-2-validacion-del-dto","title":"Paso 2: Validaci\u00f3n del DTO","text":"<p>Para validar el modelo <code>Book</code>, se han a\u00f1adido las siguientes anotaciones de validaci\u00f3n:</p> <ul> <li>@NotEmpty: Asegura que el campo no est\u00e9 vac\u00edo. Se utiliza principalmente en campos de texto para asegurarse de que no sean nulos y que contengan al menos un car\u00e1cter, excluyendo los espacios en blanco. Se aplica a los campos <code>code</code> y <code>name</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>@NotEmpty(message = \"Book code is required\") String code,\n</code></pre> <p>Valida que el campo <code>code</code> no est\u00e9 vac\u00edo.</p> <ul> <li>@NotNull: Asegura que el campo no sea nulo. Es \u00fatil para cualquier tipo de dato, asegur\u00e1ndose de que el campo debe tener un valor asignado. Se aplica al campo <code>price</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>@NotNull(message = \"Book price is required\") @DecimalMin(\"0.1\") BigDecimal \nprice,\n</code></pre> <p>Valida que el campo <code>price</code> no sea nulo.</p> <ul> <li>@DecimalMin: Valida que el campo tenga un valor m\u00ednimo espec\u00edfico. Se utiliza en campos num\u00e9ricos para asegurar que el valor sea igual o mayor que el valor especificado. Se aplica al campo <code>price</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>@DecimalMin(\"0.1\") BigDecimal price,\n</code></pre> <p>Valida que el campo <code>price</code> sea mayor o igual a 0.1.</p> <ul> <li>@NotBlank: Asegura que el campo no est\u00e9 vac\u00edo y que no sea solo espacios en blanco. Es \u00fatil para campos de texto donde no solo se necesita que el campo no sea nulo, sino que tambi\u00e9n contenga caracteres no espaciales. Se aplica a los campos <code>imageUrl</code> y <code>filePath</code>.</li> </ul> <p>Ejemplo:</p> <pre><code>@NotBlank String imageUrl,\n</code></pre> <p>Valida que el campo <code>imageUrl</code> no est\u00e9 vac\u00edo y no contenga solo espacios en blanco. Con esta configuraci\u00f3n, tanto la clase <code>BookEntity</code> como el DTO <code>Book</code> est\u00e1n listos para ser utilizados en tu aplicaci\u00f3n Spring Boot.</p>"},{"location":"get-book/#creacion-servicio","title":"Creacion Servicio","text":""},{"location":"get-book/#paso-1-crear-las-dependencias-necesarias","title":"Paso 1: Crear las Dependencias Necesarias","text":"<p>Creaci\u00f3n de <code>ApplicationProperties</code></p> <p>Dentro del paquete <code>config</code>, creamos un <code>record</code> Java llamado <code>ApplicationProperties</code> que encapsula las propiedades de configuraci\u00f3n de la aplicaci\u00f3n.</p> ApplicationProperties.java<pre><code>@ConfigurationProperties(prefix = \"book\")\npublic record ApplicationProperties(@DefaultValue(\"10\") @Min(1) int pageSize) {}\n</code></pre> <ul> <li>L\u00ednea 1:</li> </ul> <pre><code>@ConfigurationProperties(prefix = \"book\")\n</code></pre> <ul> <li> <p>Esta anotaci\u00f3n indica que las propiedades de configuraci\u00f3n de este <code>record</code> estar\u00e1n prefijadas con <code>book</code> en el archivo <code>application.properties</code> o <code>application.yml</code>. </p> <ul> <li>Por ejemplo:<ul> <li><code>book.pageSize=10</code></li> </ul> </li> </ul> </li> <li> <p>L\u00edneas 2:</p> </li> </ul> <pre><code>public record ApplicationProperties(@DefaultValue(\"10\") @Min(1) int pageSize) {}\n</code></pre> <p>Define el <code>record</code> <code>ApplicationProperties</code> que encapsula las propiedades de configuraci\u00f3n. El campo <code>pageSize</code> asegura que el tama\u00f1o de p\u00e1gina m\u00ednimo sea 1 y tiene un valor predeterminado de 10.</p> <p>Anotaci\u00f3n en la Clase Principal</p> <p>Para habilitar el escaneo y la configuraci\u00f3n autom\u00e1tica de las propiedades, a\u00f1adimos la anotaci\u00f3n <code>@ConfigurationPropertiesScan</code> en la clase principal <code>BookstoreApplication</code>.</p> BookstoreApplication.java<pre><code>import org.springframework.boot.context.properties.ConfigurationPropertiesScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\n@ConfigurationPropertiesScan\npublic class BookstoreApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(BookstoreApplication.class, args);\n    }\n}\n</code></pre> <ul> <li> <p>Anotaci\u00f3n <code>@ConfigurationPropertiesScan</code>:</p> <ul> <li>Habilita el escaneo de las clases anotadas con <code>@ConfigurationProperties</code> en el paquete y sus subpaquetes. Esto es necesario para que Spring Boot detecte y configure las propiedades autom\u00e1ticamente.</li> </ul> </li> </ul>"},{"location":"get-book/#paso-2-creacion-de-bookmapper","title":"Paso 2: Creacion de <code>BookMapper</code>","text":"<p>Dentro del paquete <code>mapper</code>, creamos una clase llamada <code>BookMapper</code> que contiene m\u00e9todos para convertir entre <code>BookEntity</code> y <code>Book</code>.</p> BookMapper.java<pre><code>package com.jconfdominicana.bookstore.mapper;\n\nimport com.jconfdominicana.bookstore.dto.Book;\nimport com.jconfdominicana.bookstore.model.BookEntity;\n\npublic class BookMapper {\n    public static Book toBook(BookEntity entity) {\n        return new Book(\n                entity.getId().toString(),\n                entity.getCode(),\n                entity.getName(),\n                entity.getDescription(),\n                entity.getPrice(),\n                entity.getImageUrl(),\n                entity.getFilePath());\n    }\n\n    public static BookEntity toEntity(Book book) {\n        return new BookEntity(\n                Long.valueOf(book.id()),\n                book.code(),\n                book.name(),\n                book.description(),\n                book.price(),\n                book.imageUrl(),\n                book.filePath(),\n                null,\n                null);\n    }\n}\n</code></pre> <ul> <li>L\u00edneas 6-16:</li> </ul> <pre><code>public static Book toBook(BookEntity entity) {\n    return new Book(\n            entity.getId().toString(),\n            entity.getCode(),\n            entity.getName(),\n            entity.getDescription(),\n            entity.getPrice(),\n            entity.getImageUrl(),\n            entity.getFilePath());\n}\n</code></pre> <p>Define el m\u00e9todo <code>toBook</code> que convierte un <code>BookEntity</code> en un <code>Book</code>.</p> <ul> <li>L\u00edneas 18-29:</li> </ul> <pre><code>public static BookEntity toEntity(Book book) {\n    return new BookEntity(\n            Long.valueOf(book.id()),\n            book.code(),\n            book.name(),\n            book.description(),\n            book.price(),\n            book.imageUrl(),\n            book.filePath(),\n            null,\n            null);\n}\n</code></pre> <p>Define el m\u00e9todo <code>toEntity</code> que convierte un <code>Book</code> en un <code>BookEntity</code>.</p> <p>Beneficios de Usar un <code>Mapper</code></p> <ul> <li> <p>Separaci\u00f3n de Responsabilidades: Usar un <code>mapper</code> permite mantener una clara separaci\u00f3n entre la l\u00f3gica de la aplicaci\u00f3n y la l\u00f3gica de persistencia. Esto significa que las clases de entidad (<code>@Entity</code>) solo se utilizan para la persistencia de datos, mientras que los DTO (Data Transfer Objects) se utilizan para transferir datos entre las capas de la aplicaci\u00f3n.</p> </li> <li> <p>Simplificaci\u00f3n del C\u00f3digo: Los mappers simplifican el c\u00f3digo al encapsular la l\u00f3gica de conversi\u00f3n entre entidades y DTOs en un solo lugar. Esto reduce la repetici\u00f3n de c\u00f3digo y hace que el mantenimiento sea m\u00e1s sencillo.</p> </li> <li> <p>Mejor Mantenibilidad: Si cambian los requisitos de la aplicaci\u00f3n, es m\u00e1s f\u00e1cil actualizar la l\u00f3gica de mapeo en una sola clase en lugar de buscar y actualizar m\u00faltiples lugares en el c\u00f3digo.</p> </li> <li> <p>Flexibilidad: Permite personalizar los objetos que se env\u00edan y reciben en las diferentes capas de la aplicaci\u00f3n sin afectar directamente a las entidades de base de datos. Por ejemplo, puedes agregar campos adicionales en el DTO para fines de visualizaci\u00f3n sin cambiar la estructura de la base de datos.</p> </li> <li> <p>Evita Exposici\u00f3n de Entidades: No se recomienda exponer directamente las entidades (<code>@Entity</code>) a las capas superiores de la aplicaci\u00f3n (como la capa de presentaci\u00f3n). Esto protege las entidades de cambios accidentales y asegura que solo los datos necesarios se transfieran entre las capas.</p> </li> </ul>"},{"location":"get-book/#paso-3-crear-la-clase-del-servicio","title":"Paso 3: Crear la Clase del Servicio","text":"<p>Dentro del paquete <code>service</code>, creamos una clase llamada <code>BookService</code>. Usamos las anotaciones <code>@Service</code> y <code>@Transactional</code> para indicar que esta clase es un servicio de Spring y que las transacciones deben ser manejadas autom\u00e1ticamente.</p> <p>Definir la Clase del Servicio</p> BookService.java<pre><code>package com.jconfdominicana.bookstore.service;\n\nimport com.jconfdominicana.bookstore.config.ApplicationProperties;\nimport com.jconfdominicana.bookstore.dto.Book;\nimport com.jconfdominicana.bookstore.dto.PagedResult;\nimport com.jconfdominicana.bookstore.mapper.BookMapper;\nimport com.jconfdominicana.bookstore.model.BookEntity;\nimport com.jconfdominicana.bookstore.repository.BookRepository;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\n@Transactional\npublic class BookService {\n\n    private final BookRepository bookRepository;\n    private final ApplicationProperties properties;\n\n    public BookService(BookRepository bookRepository, ApplicationProperties properties) {\n        this.bookRepository = bookRepository;\n        this.properties = properties;\n    }\n\n    public PagedResult&lt;Book&gt; getBooks(int pageNo) {\n        Sort sort = Sort.by(\"name\").ascending();\n        pageNo = pageNo &lt;= 1 ? 0 : pageNo - 1;\n        Pageable pageable = PageRequest.of(pageNo, properties.pageSize(), sort);\n        Page&lt;Book&gt; booksPage = bookRepository.findAll(pageable).map(BookMapper::toBook);\n\n        return new PagedResult&lt;&gt;(\n                booksPage.getContent(),\n                booksPage.getTotalElements(),\n                booksPage.getNumber() + 1,\n                booksPage.getTotalPages(),\n                booksPage.isFirst(),\n                booksPage.isLast(),\n                booksPage.hasNext(),\n                booksPage.hasPrevious());\n    }\n\n    public Book getBookByCode(String code) {\n        BookEntity bookEntity = bookRepository.findByCode(code)\n                .orElseThrow(() -&gt; new RuntimeException (\"Book not found with code: \" + code));\n        return BookMapper.toBook(bookEntity);\n    }\n\n    public Book saveBook(Book book) {\n        BookEntity bookEntity = BookMapper.toEntity(book);\n        bookEntity = bookRepository.save(bookEntity);\n        return BookMapper.toBook(bookEntity);\n    }\n}\n</code></pre> <ul> <li>L\u00edneas 17-18:<ul> <li><code>@Service</code>: Indica que esta clase es un servicio de Spring.</li> <li><code>@Transactional</code>: Asegura que todas las operaciones en el servicio sean transaccionales.</li> </ul> </li> <li>L\u00edneas 19-27:</li> </ul> <pre><code>public class BookService {\n    private final BookRepository bookRepository;\n    private final ApplicationProperties properties;\n\n    public BookService(BookRepository bookRepository, ApplicationProperties properties) {\n        this.bookRepository = bookRepository;\n        this.properties = properties;\n    }\n}\n</code></pre> <p>Define el constructor que inyecta las dependencias <code>BookRepository</code> y <code>ApplicationProperties</code>.</p> <p>M\u00e9todo para Recuperar Libros Usando Paginaci\u00f3n</p> <ul> <li>L\u00edneas 29-44:</li> </ul> <pre><code>public PagedResult&lt;Book&gt; getBooks(int pageNo) {\n    Sort sort = Sort.by(\"name\").ascending();\n    pageNo = pageNo &lt;= 1 ? 0 : pageNo - 1;\n    Pageable pageable = PageRequest.of(pageNo, properties.pageSize(), sort);\n    Page&lt;Book&gt; booksPage = bookRepository.findAll(pageable).map(BookMapper::toBook);\n\n    return new PagedResult&lt;&gt;(\n            booksPage.getContent(),\n            booksPage.getTotalElements(),\n            booksPage.getNumber() + 1,\n            booksPage.getTotalPages(),\n            booksPage.isFirst(),\n            booksPage.isLast(),\n            booksPage.hasNext(),\n            booksPage.hasPrevious());\n}\n</code></pre> <ul> <li><code>getBooks(int pageNo)</code>: M\u00e9todo para recuperar los libros usando paginaci\u00f3n.</li> <li><code>Sort sort = Sort.by(\"name\").ascending()</code>: Define la ordenaci\u00f3n ascendente por el campo <code>name</code>.</li> <li><code>Pageable pageable = PageRequest.of(pageNo, properties.pageSize(), sort)</code>: Crea un objeto <code>Pageable</code> con la p\u00e1gina actual, el tama\u00f1o de p\u00e1gina y la ordenaci\u00f3n.</li> <li><code>Page&lt;Book&gt; booksPage = bookRepository.findAll(pageable).map(BookMapper::toBook)</code>: Recupera una p\u00e1gina de libros y los convierte a DTO <code>Book</code>.</li> <li><code>return new PagedResult&lt;&gt;(...)</code>: Retorna un objeto PagedResult con los detalles de la p\u00e1gina de libros.</li> </ul> <p>M\u00e9todo para Recuperar Libros por el Campo code</p> <ul> <li>L\u00edneas 46-50:</li> </ul> <pre><code>public Book getBookByCode(String code) {\n    BookEntity bookEntity = bookRepository.findByCode(code)\n            .orElseThrow(() -&gt; new RuntimeException (\"Book not found with code: \" + code));\n    return BookMapper.toBook(bookEntity);\n}\n</code></pre> <ul> <li><code>getBookByCode(String code)</code>: M\u00e9todo para recuperar un libro por su c\u00f3digo.</li> <li><code>bookRepository.findByCode(code)</code>: Busca un libro por su c\u00f3digo.</li> <li><code>.orElseThrow(...)</code>: Lanza una excepci\u00f3n si el libro no se encuentra.</li> <li><code>return BookMapper.toBook(bookEntity)</code>: Convierte y retorna el  <code>BookEntity</code> a un DTO <code>Book</code>.</li> </ul> <p>M\u00e9todo para Guardar un Libro</p> <ul> <li>L\u00edneas 52-56:</li> </ul> <pre><code>public Book saveBook(Book book) {\n    BookEntity bookEntity = BookMapper.toEntity(book);\n    bookEntity = bookRepository.save(bookEntity);\n    return BookMapper.toBook(bookEntity);\n}\n</code></pre> <ul> <li><code>saveBook(Book book)</code>: M\u00e9todo para guardar un libro.</li> <li><code>BookEntity bookEntity = BookMapper.toEntity(book)</code>: Convierte el DTO <code>Book</code> en una entidad <code>BookEntity</code>.</li> <li><code>bookEntity = bookRepository.save(bookEntity)</code>: Guarda la entidad en la base de datos.</li> <li><code>return BookMapper.toBook(bookEntity)</code>: Convierte y retorna la entidad guardada como un DTO <code>Book</code>.</li> </ul>"},{"location":"get-book/#creacion-paginacion","title":"Creacion Paginaci\u00f3n","text":"<p>La paginaci\u00f3n es una t\u00e9cnica utilizada para dividir un conjunto grande de datos en partes m\u00e1s peque\u00f1as, llamadas p\u00e1ginas, para facilitar su visualizaci\u00f3n y manipulaci\u00f3n. En una aplicaci\u00f3n web, la paginaci\u00f3n permite cargar y mostrar datos de manera eficiente, mejorando la experiencia del usuario y el rendimiento del sistema.</p> <p>Paso 1: Crear la Clase PagedResult Dentro del paquete <code>dto</code>, creamos un <code>record</code> Java llamado <code>PagedResult</code> que encapsula los datos de la paginaci\u00f3n. Un <code>record</code> en Java es una clase especial que proporciona una manera concisa de definir clases inmutables con campos.</p> PagedResult.java<pre><code>public record PagedResult&lt;T&gt;(\n        List&lt;T&gt; data,\n        long totalElements,\n        int pageNumber,\n        int totalPages,\n        boolean isFirst,\n        boolean isLast,\n        boolean hasNext,\n        boolean hasPrevious) {}\n</code></pre> <ul> <li>L\u00ednea 1: <code>public record PagedResult&lt;T&gt;()</code>: Define el <code>record</code> <code>PagedResult</code> que encapsula los datos de la paginaci\u00f3n. El uso de <code>record</code> en Java permite crear una clase inmutable con un conjunto fijo de campos.</li> </ul> <p>Campos de PagedResult</p> <ul> <li> <p>L\u00ednea 2: <code>List&lt;T&gt; data</code>: Una lista que contiene los datos de la p\u00e1gina actual. El tipo gen\u00e9rico <code>T</code> permite que <code>PagedResult</code> sea reutilizable para cualquier tipo de datos.</p> <pre><code>    List&lt;T&gt; data\n</code></pre> <ul> <li><code>data</code>: Los elementos de la p\u00e1gina actual.</li> </ul> </li> <li> <p>L\u00ednea 3: <code>long totalElements</code>: El n\u00famero total de elementos en el conjunto de datos completo.</p> <pre><code>long totalElements\n</code></pre> <ul> <li><code>totalElements</code>: El total de elementos en la colecci\u00f3n completa.</li> </ul> </li> <li> <p>L\u00ednea 4: <code>int pageNumber</code>: El n\u00famero de la p\u00e1gina actual (comenzando desde 1).</p> <pre><code>int pageNumber\n</code></pre> <ul> <li><code>pageNumber</code>: El n\u00famero de la p\u00e1gina actual, \u00fatil para la navegaci\u00f3n.</li> </ul> </li> <li> <p>L\u00ednea 5: <code>int totalPages</code>: El n\u00famero total de p\u00e1ginas disponibles.</p> <pre><code>int totalPages\n</code></pre> <ul> <li><code>totalPages</code>: El total de p\u00e1ginas basado en el tama\u00f1o de p\u00e1gina y el n\u00famero total de elementos.</li> </ul> </li> <li> <p>L\u00ednea 6: boolean isFirst: Un indicador booleano que indica si esta es la primera p\u00e1gina.</p> <pre><code>boolean isFirst\n</code></pre> <ul> <li>isFirst: true si es la primera p\u00e1gina, de lo contrario false.</li> </ul> </li> <li> <p>L\u00ednea 7: boolean isLast: Un indicador booleano que indica si esta es la \u00faltima p\u00e1gina.</p> <pre><code>boolean isLast\n</code></pre> <ul> <li><code>isLast</code>: true si es la \u00faltima p\u00e1gina, de lo contrario false.</li> </ul> </li> <li> <p>L\u00ednea 8: boolean hasNext: Un indicador booleano que indica si hay una p\u00e1gina siguiente disponible.</p> <pre><code>boolean hasNext\n</code></pre> <ul> <li><code>hasNext</code>: true si hay una p\u00e1gina siguiente, de lo contrario false.</li> </ul> </li> <li> <p>L\u00ednea 9: boolean hasPrevious: Un indicador booleano que indica si hay una p\u00e1gina anterior disponible.</p> <pre><code>boolean hasPrevious\n</code></pre> <ul> <li><code>hasPrevious</code>: true si hay una p\u00e1gina anterior, de lo contrario false.</li> </ul> </li> </ul> <p>Uso del PagedResult</p> <p>El <code>PagedResult</code> se utiliza en el servicio para encapsular los resultados de la paginaci\u00f3n y devolverlos al cliente de una manera estructurada y f\u00e1cil de usar.</p>"},{"location":"get-book/#creacion-controlador","title":"Creaci\u00f3n Controlador","text":""},{"location":"get-book/#descripcion-del-controlador","title":"Descripci\u00f3n del Controlador","text":"<p>El controlador es la capa de la aplicaci\u00f3n encargada de manejar las solicitudes HTTP, procesarlas y devolver las respuestas apropiadas. Utilizamos la anotaci\u00f3n <code>@RestController</code> para definir un controlador RESTful en Spring Boot.</p> M\u00e9todo Descripci\u00f3n <code>GET</code>      Recupera recursos <code>POST</code>  Guarda recursos <code>PUT</code>  Actualiza recursos <code>DELETE</code>      Elimina recursos"},{"location":"get-book/#paso-1-creacion-de-la-clase-bookcontroller","title":"Paso 1: Creaci\u00f3n de la Clase <code>BookController</code>","text":"<ol> <li>Definir la Clase del Controlador: En el paquete <code>controller</code> de la aplicaci\u00f3n, crear una clase llamada <code>BookController</code>.</li> <li>Anotar la Clase como un Controlador REST: Utilizar la anotaci\u00f3n <code>@RestController</code> para convertir la clase en un controlador REST.</li> <li>Inyectar el Servicio: Inyectar <code>BookService</code> para manejar la l\u00f3gica de negocio.</li> <li>Definir los M\u00e9todos del Controlador: Crear m\u00e9todos para manejar las diferentes operaciones CRUD (Create, Read, Update, Delete) para la entidad <code>Book</code>.</li> </ol> BookController.java<pre><code>package com.jconfdominicana.bookstore.controller;\n\nimport com.jconfdominicana.bookstore.dto.Book;\nimport com.jconfdominicana.bookstore.dto.PagedResult;\nimport com.jconfdominicana.bookstore.exception.BookNotFoundException;\nimport com.jconfdominicana.bookstore.service.BookService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/api/books\")\npublic class BookController {\n\n    private final BookService bookService;\n\n    @Autowired\n    public BookController(BookService bookService) {\n        this.bookService = bookService;\n    }\n\n    @GetMapping\n    public PagedResult&lt;Book&gt; getBooks(@RequestParam(name = \"page\", defaultValue = \"1\") int pageNo) {\n        return bookService.getBooks(pageNo);\n    }\n\n    @GetMapping(\"/{code}\")\n    public ResponseEntity&lt;Book&gt; getBookByCode(@PathVariable String code) {\n        Book book = bookService.getBookByCode(code);\n        return ResponseEntity.ok(book);\n    }\n\n    @PostMapping\n    public ResponseEntity&lt;Book&gt; createBook(@RequestBody Book book) {\n        Book createdBook = bookService.saveBook(book);\n        return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.CREATED);\n    }\n}\n</code></pre> <p>Descripci\u00f3n de los M\u00e9todos</p> <p>M\u00e9todo <code>getBooks</code></p> <ul> <li>Prop\u00f3sito: Recupera una lista paginada de libros.</li> <li>Ruta: <code>/api/books</code></li> <li>M\u00e9todo HTTP: <code>GET</code></li> <li>Anotaci\u00f3n: <code>@GetMapping</code> indica que este m\u00e9todo manejar\u00e1 solicitudes GET a la ruta <code>/books</code>.</li> <li>Par\u00e1metro: <code>page</code> (opcional, valor por defecto: 1). Utiliza <code>@RequestParam</code> para capturar el par\u00e1metro de la solicitud HTTP.</li> <li>Retorno: <code>PagedResult&lt;Book&gt;</code> con los libros paginados.</li> </ul> <pre><code>@GetMapping\npublic PagedResult&lt;Book&gt; getBooks(@RequestParam(name = \"page\", defaultValue = \"1\") int pageNo) {\n    return bookService.getBooks(pageNo);\n}\n</code></pre> <p>M\u00e9todo <code>getBookByCode</code></p> <ul> <li>Prop\u00f3sito: Recupera un libro por su c\u00f3digo.</li> <li>Ruta: <code>/api/books/{code}</code></li> <li>M\u00e9todo HTTP: <code>GET</code></li> <li>Anotaci\u00f3n: <code>@GetMapping</code> indica que este m\u00e9todo manejar\u00e1 solicitudes GET a la ruta <code>/books/{code}</code>.</li> <li>Par\u00e1metro: <code>code</code> (obligatorio). Utiliza <code>@PathVariable</code> para capturar el par\u00e1metro de la ruta.</li> <li>Retorno: <code>ResponseEntity&lt;Book&gt;</code> con el libro encontrado.</li> </ul> <pre><code>@GetMapping(\"/{code}\")\npublic ResponseEntity&lt;Book&gt; getBookByCode(@PathVariable String code) {\n    Book book = bookService.getBookByCode(code);\n    return ResponseEntity.ok(book);\n}\n</code></pre> <p>M\u00e9todo <code>createBook</code></p> <ul> <li>Prop\u00f3sito: Crea un nuevo libro.</li> <li>Ruta: <code>/api/books</code></li> <li>M\u00e9todo HTTP: <code>POST</code></li> <li>Anotaci\u00f3n: <code>@PostMapping</code> indica que este m\u00e9todo manejar\u00e1 solicitudes POST a la ruta <code>/books</code>.</li> <li>Par\u00e1metro: <code>Book</code> (en el cuerpo de la solicitud). Utiliza <code>@RequestBody</code> para capturar el cuerpo de la solicitud HTTP.</li> <li>Retorno: <code>ResponseEntity&lt;Book&gt;</code> con el libro creado y el estado HTTP 201 (Created).</li> </ul> <pre><code>@PostMapping\npublic ResponseEntity&lt;Book&gt; createBook(@RequestBody Book book) {\n    Book createdBook = bookService.saveBook(book);\n    return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.CREATED);\n}\n</code></pre>"},{"location":"get-book/#adicionar-configuracion-properties","title":"Adicionar configuracion Properties","text":"<p>El archivo <code>application.properties</code> se utiliza en Spring Boot para configurar varias propiedades de la aplicaci\u00f3n. Aqu\u00ed, configuramos el nombre de la aplicaci\u00f3n, el puerto del servidor, la configuraci\u00f3n de apagado del servidor, la exposici\u00f3n de puntos finales de gesti\u00f3n y la configuraci\u00f3n espec\u00edfica del servicio y de la base de datos.</p> <p>Configuraci\u00f3n B\u00e1sica de la Aplicaci\u00f3n</p> application.properties<pre><code>spring.application.name=bookstore\nserver.port=8081\nserver.shutdown=graceful\nmanagement.endpoints.web.exposure.include=*\nmanagement.info.git.mode=full\n\n######## Book Service Configuration  #########\nbook.page-size=10\n\n######## Database Configuration  #########\nspring.datasource.url=${DB_URL:jdbc:postgresql://localhost:15432/postgres}\nspring.datasource.username=${DB_USERNAME:postgres}\nspring.datasource.password=${DB_PASSWORD:postgres}\nspring.jpa.open-in-view=false\n</code></pre> <ul> <li> <p>L\u00ednea 1-5:</p> <ul> <li><code>spring.application.name=bookstore</code>: Define el nombre de la aplicaci\u00f3n.</li> <li><code>server.port=8081</code>: Establece el puerto en el que la aplicaci\u00f3n se ejecutar\u00e1. En este caso, el puerto 8081.</li> <li><code>server.shutdown=graceful</code>: Configura el servidor para realizar un apagado ordenado, permitiendo que las solicitudes actuales se completen antes de apagar el servidor.</li> <li><code>management.endpoints.web.exposure.include=*</code>: Expone todos los Endpoint de gesti\u00f3n.</li> <li><code>management.info.git.mode=full</code>: Configura el modo de exposici\u00f3n de informaci\u00f3n de Git a <code>full</code>.</li> </ul> </li> <li> <p>L\u00ednea 8:</p> <ul> <li>book.page-size=10: Define el tama\u00f1o de la p\u00e1gina para la paginaci\u00f3n del servicio de libros. Esto significa que cada p\u00e1gina tendr\u00e1 un m\u00e1ximo de 10 libros.</li> </ul> </li> <li> <p>L\u00ednea 11-14:  </p> <ul> <li><code>spring.datasource.url=${DB_URL:jdbc:postgresql://localhost:15432/postgres</code>: Configura la URL de la base de datos. Utiliza una variable de entorno <code>DB_URL</code> si est\u00e1 disponible; de lo contrario, usa el valor por defecto <code>jdbc:postgresql://localhost:15432/postgres</code>.</li> <li><code>spring.datasource.username=${DB_USERNAME:postgres}</code>: Configura el nombre de usuario de la base de datos. Utiliza una variable de entorno <code>DB_USERNAME</code> si est\u00e1 disponible; de lo contrario, usa el valor por defecto <code>postgres</code>.</li> <li><code>spring.datasource.password=${DB_PASSWORD:postgres}</code>: Configura la contrase\u00f1a de la base de datos. Utiliza una variable de entorno <code>DB_PASSWORD</code> si est\u00e1 disponible; de lo contrario, usa el valor por defecto <code>postgres</code>.</li> <li><code>spring.jpa.open-in-view=false</code>: Desactiva la opci\u00f3n de open-in-view para mejorar el rendimiento.  </li> </ul> </li> </ul>"},{"location":"get-book/#adicionar-flyway","title":"Adicionar flyway","text":"<p>Flyway es una herramienta de migraci\u00f3n de base de datos que ayuda a gestionar cambios en el esquema de la base de datos de manera controlada y versionada. Utilizaremos Flyway para crear y poblar la tabla books.</p> <p>Archivo de Migraci\u00f3n <code>V1__create_books_table.sql</code> Este archivo crea la secuencia y la tabla <code>books</code>.</p> V1__create_books_table.sql<pre><code>create sequence book_id_seq start with 1 increment by 50;\n\ncreate table books (\n    id bigint default nextval('book_id_seq') not null ,\n    code text not null unique,\n    name varchar(255) not null,\n    description text,\n    price numeric not null,\n    cover_path varchar(250) DEFAULT NULL,\n    file_path varchar(250) DEFAULT NULL,\n    created timestamp NOT NULL,\n    modified timestamp DEFAULT NULL,\n    primary key (id)\n);\n</code></pre> <ul> <li><code>create sequence book_id_seq start with 1 increment by 50;</code>: Crea una secuencia para generar los identificadores \u00fanicos de los libros, comenzando en 1 y aumentando en 50.</li> <li><code>create table books (...)</code>: Crea la tabla books con los siguientes campos:<ul> <li><code>id</code>: Identificador \u00fanico de tipo bigint, generado autom\u00e1ticamente utilizando la secuencia book_id_seq.</li> <li><code>code</code>: C\u00f3digo del libro, de tipo text, \u00fanico y no nulo.</li> <li><code>name</code>: Nombre del libro, de tipo varchar(255), no nulo.</li> <li><code>description</code>: Descripci\u00f3n del libro, de tipo text.</li> <li><code>price</code>: Precio del libro, de tipo numeric, no nulo.</li> <li><code>cover_path</code>: Ruta de la imagen de portada del libro, de tipo varchar(250), opcional.</li> <li><code>file_path</code>: Ruta del archivo del libro, de tipo varchar(250), opcional.</li> <li><code>created</code>: Fecha de creaci\u00f3n del registro, de tipo timestamp, no nulo.</li> <li><code>modified</code>: Fecha de modificaci\u00f3n del registro, de tipo timestamp, opcional.</li> <li><code>primary key (id)</code>: Define id como la clave primaria de la tabla.</li> </ul> </li> </ul> <p>Archivo de Datos <code>V2__add_books_data.sql</code></p> <p>Este archivo inserta datos iniciales en la tabla books.</p> V2__add_books_data.sql<pre><code>insert into books(code, name, description, price, cover_path, file_path,created) values\n('P100','The Hunger Games','Winning will make you famous. Losing means certain death...', 34.0,'','',current_timestamp),\n('P101','To Kill a Mockingbird','The unforgettable novel of a childhood in a sleepy Southern town and the crisis of conscience that rocked it...', 45.40,'','', current_timestamp),\n('P102','The Chronicles of Narnia','Journeys to the end of the world, fantastic creatures, and epic battles between good and evil\u2014what more could any reader ask for in one book?...', 44.50,'','', current_timestamp);\n</code></pre>"},{"location":"get-book/#probar-el-endpoint","title":"Probar el Endpoint","text":""},{"location":"get-book/#probando-el-endpoint-general","title":"Probando el Endpoint General","text":"<p>Esta es la url que vamos a probar:</p> <pre><code>curl --location 'http://localhost:8081/api/books'\n</code></pre> <p>El resultado esperado es el siguiente:</p> <p>En esta respuesta, podemos observar que se obtiene una lista de libros disponibles en nuestra base de datos. Cada libro contiene informaci\u00f3n detallada como <code>id</code>, <code>c\u00f3digo</code>, <code>nombre</code>, <code>descripci\u00f3n</code>, <code>precio</code>, entre otros.</p> <p>Para realizar esta prueba en Postman:</p> <ol> <li>Configurar la Solicitud:<ul> <li>M\u00e9todo: GET</li> <li>URL: <code>http://localhost:8081/api/books</code></li> </ul> </li> <li>Ejecutar la Prueba:<ul> <li>Hacer clic en el bot\u00f3n \"Send\" y observar el resultado en la pesta\u00f1a \"Body\".</li> </ul> </li> </ol> <p>El resultado esperado en Postman es similar a la imagen proporcionada.</p> <p></p>"},{"location":"get-book/#probando-el-endpoint-por-codigo-de-libro","title":"Probando el Endpoint por C\u00f3digo de Libro","text":"<p>Vamos a probar el segundo endpoint, donde realizaremos una b\u00fasqueda espec\u00edfica por el c\u00f3digo del libro. La URL que utilizaremos es:</p> <pre><code>curl --location 'http://localhost:8081/api/books/P101'\n</code></pre> <p>El resultado esperado es el siguiente:</p> <p>Aqu\u00ed, podemos observar la informaci\u00f3n detallada de un libro espec\u00edfico identificado por el c\u00f3digo <code>P101</code>.</p> <p>Para realizar esta prueba en Postman:</p> <ol> <li> <p>Configurar la Solicitud:</p> <ul> <li>M\u00e9todo: GET</li> <li>URL: <code>http://localhost:8081/api/books/P101</code></li> </ul> </li> <li> <p>Ejecutar la Prueba:</p> <ul> <li>Hacer clic en el bot\u00f3n \"Send\" y observar el resultado en la pesta\u00f1a \"Body\".</li> </ul> </li> </ol> <p>El resultado esperado en Postman es similar a la imagen proporcionada.</p> <p></p>"},{"location":"get-book/#manejo-de-errores-para-codigos-no-existentes","title":"Manejo de Errores para C\u00f3digos No Existentes","text":"<p>Nos preguntamos qu\u00e9 pasa si en esta consulta le enviamos un c\u00f3digo de libro que no existe. Vamos a probar con el c\u00f3digo <code>P103</code>:</p> <pre><code>curl --location 'http://localhost:8081/api/books/P103'\n</code></pre> <p>El resultado obtenido es el siguiente:</p> <p></p> <p>En este caso, observamos que el resultado no es el esperado, ya que se retorna un estado <code>500 Internal Server Error</code> en lugar de un <code>404 Not Found</code>. Esto indica que el servidor no manej\u00f3 adecuadamente la ausencia del libro con el c\u00f3digo proporcionado.</p>"},{"location":"get-book/#corrigiendo-el-manejo-de-errores","title":"Corrigiendo el Manejo de Errores","text":"<p>Para manejar este tipo de errores de manera adecuada y proporcionar una respuesta m\u00e1s descriptiva, vamos a realizar las siguientes correcciones en nuestro c\u00f3digo:</p> <ol> <li>Actualizar el Servicio:<ul> <li>Modificar el m\u00e9todo de servicio para lanzar una excepci\u00f3n controlada en lugar de una excepci\u00f3n gen\u00e9rica.</li> </ul> </li> <li>Controlador de Excepciones Globales:<ul> <li>Implementar un controlador de excepciones globales en nuestro proyecto Spring Boot para manejar los errores de manera centralizada.</li> </ul> </li> </ol> <p>Con estas modificaciones, lograremos que el sistema retorne un estado <code>404 Not Found</code> cuando se busque un libro que no existe en la base de datos, detallando mejor los errores que nos encontremos y mejorando la experiencia del usuario.</p>"},{"location":"get-book/#manejo-de-excepciones-de-la-api","title":"Manejo de Excepciones de la API","text":"<p>El manejo de excepciones en una API es crucial para proporcionar mensajes de error claros y \u00fatiles cuando algo sale mal. Esto ayuda a los clientes de la API a entender por qu\u00e9 una solicitud fall\u00f3 y c\u00f3mo pueden corregirla. Vamos a crear una excepci\u00f3n personalizada <code>BookNotFoundException</code> y un manejador global de excepciones para nuestra API.</p>"},{"location":"get-book/#excepcion-personalizada-booknotfoundexception","title":"Excepci\u00f3n Personalizada <code>BookNotFoundException</code>","text":"<p>La excepci\u00f3n <code>BookNotFoundException</code> se utiliza para manejar la situaci\u00f3n en la que no se encuentra un libro con el c\u00f3digo especificado en la base de datos. Esta excepci\u00f3n permite devolver un c\u00f3digo de estado <code>HTTP 404 (Not Found)</code> con un mensaje claro que indica el problema.</p> BookNotFoundException.java<pre><code>public class BookNotFoundException extends RuntimeException {\n    public BookNotFoundException(String message) {\n        super(message);\n    }\n\n    public static BookNotFoundException forCode(String code) {\n        return new BookNotFoundException(\"Book with code \" + code + \" not found\");\n    }\n}\n</code></pre>"},{"location":"get-book/#implementacion-excepciones-de-la-api","title":"Implementaci\u00f3n Excepciones de la API","text":"<ol> <li>Crear la Clase de Excepci\u00f3n: Dentro del paquete <code>exception</code>, crear una clase llamada <code>BookNotFoundException</code>.</li> </ol> <pre><code>package com.jconfdominicana.bookstore.exception;\n\n/**\n * Excepci\u00f3n personalizada para manejar el caso en el que un libro no se encuentra\n * en la base de datos.\n */\npublic class BookNotFoundException extends RuntimeException {\n    /**\n     * Constructor que acepta un mensaje de error.\n     *\n     * @param message El mensaje de error.\n     */\n    public BookNotFoundException(String message) {\n        super(message);\n    }\n\n    /**\n     * M\u00e9todo est\u00e1tico para crear una excepci\u00f3n con un mensaje espec\u00edfico\n     * para el c\u00f3digo del libro.\n     *\n     * @param code El c\u00f3digo del libro no encontrado.\n     * @return Una nueva instancia de BookNotFoundException.\n     */\n    public static BookNotFoundException forCode(String code) {\n        return new BookNotFoundException(\"Book with code \" + code + \" not found\");\n    }\n}\n</code></pre> <p>Descripci\u00f3n del C\u00f3digo</p> <ul> <li> <p>Clase <code>BookNotFoundException</code>:</p> <ul> <li>Prop\u00f3sito: Manejar la situaci\u00f3n en la que un libro no se encuentra en la base de datos.</li> <li>Herencia: Extiende <code>RuntimeException</code> para ser utilizada como una excepci\u00f3n no verificada.</li> </ul> </li> <li> <p>Constructor:</p> <ul> <li>Acepta un mensaje de error como par\u00e1metro y lo pasa a la clase base <code>RuntimeException</code>.</li> </ul> </li> <li> <p>M\u00e9todo est\u00e1tico forCode:</p> <ul> <li>Facilita la creaci\u00f3n de una instancia de <code>BookNotFoundException</code> con un mensaje espec\u00edfico que incluye el c\u00f3digo del libro no encontrado.</li> </ul> </li> </ul>"},{"location":"get-book/#manejando-excepciones-de-forma-global","title":"Manejando Excepciones de Forma Global","text":"<p>Para manejar las excepciones de forma global y devolver respuestas HTTP apropiadas, podemos crear un manejador global de excepciones usando @ControllerAdvice.</p>"},{"location":"get-book/#implementacion-excepciones-de-forma-global","title":"Implementaci\u00f3n Excepciones de Forma Global","text":"<ul> <li>Crear la Clase de Manejador Global de Excepciones: Dentro del paquete <code>exception</code>, crear una clase llamada <code>GlobalExceptionHandler</code>.</li> </ul> <pre><code>package com.jconfdominicana.bookstore.exception;\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\n\n/**\n * Manejador global de excepciones para la aplicaci\u00f3n.\n */\n@RestControllerAdvice\npublic class GlobalExceptionHandler {\n\n    /**\n     * Maneja la excepci\u00f3n BookNotFoundException.\n     *\n     * @param ex La excepci\u00f3n capturada.\n     * @return Una respuesta HTTP con el mensaje de error y el estado 404.\n     */\n    @ExceptionHandler(BookNotFoundException.class)\n    public ResponseEntity&lt;String&gt; handleBookNotFoundException(BookNotFoundException ex) {\n        return new ResponseEntity&lt;&gt;(ex.getMessage(), HttpStatus.NOT_FOUND);\n    }\n\n    // Otros manejadores de excepciones pueden ser a\u00f1adidos aqu\u00ed\n}\n</code></pre> <p>Descripci\u00f3n del C\u00f3digo</p> <ul> <li> <p>Clase <code>GlobalExceptionHandler</code>:</p> <ul> <li>Prop\u00f3sito: Manejar excepciones de forma global en la aplicaci\u00f3n.</li> <li>Anotaci\u00f3n <code>@RestControllerAdvice</code>: Indica que esta clase proporciona consejos globales para los controladores y maneja excepciones arrojadas por los m\u00e9todos de controlador.</li> </ul> </li> <li> <p>M\u00e9todo <code>handleBookNotFoundException</code>:</p> <ul> <li>Prop\u00f3sito: Manejar la excepci\u00f3n <code>BookNotFoundException</code>.</li> <li>Anotaci\u00f3n <code>@ExceptionHandler(BookNotFoundException.class)</code>: Indica que este m\u00e9todo manejar\u00e1 excepciones de tipo BookNotFoundException.</li> <li>Par\u00e1metro <code>ex</code>: La excepci\u00f3n capturada.</li> <li>Retorno: Devuelve una respuesta HTTP con el mensaje de error y el estado <code>404 (Not Found)</code>.</li> </ul> </li> </ul>"},{"location":"get-book/#implementando-las-excepciones-en-el-servicio","title":"Implementando las Excepciones en el Servicio","text":"<p>Modificamos en la clase de servicio el m\u00e9todo getBookByCode para usar la nueva clase <code>BookNotFoundException</code>:</p> <pre><code>public Book getBookByCode(String code) {\n    BookEntity bookEntity = bookRepository.findByCode(code)\n            .orElseThrow(() -&gt; new BookNotFoundException(\"Book not found with code: \" + code));\n    return BookMapper.toBook(bookEntity);\n}\n</code></pre> <p>Despu\u00e9s de realizar estas modificaciones, volvemos a ejecutar la prueba y este es el nuevo resultado, como se puede observar en la imagen:</p> <p>En este caso, el sistema retorna correctamente un estado <code>404 Not Found</code> cuando no se encuentra un libro con el c\u00f3digo especificado, con un mensaje claro que indica que el libro no fue encontrado.</p> <p></p>"},{"location":"get-book/#enlace-a-codigo-http","title":"Enlace a C\u00f3digo HTTP","text":"<p>Si quieres saber m\u00e1s sobre los c\u00f3digo m\u00e1s usado en HTTP, te comparto el siguiente enlace C\u00f3digo HTTP.</p>"},{"location":"get-book/#subida-de-archivos","title":"Subida de Archivos","text":""},{"location":"get-book/#crear-la-clase-filesystemstorageservice","title":"Crear la clase FileSystemStorageService","text":"<p>La clase <code>FileSystemStorageService</code> se encarga de manejar la subida, almacenamiento, carga y eliminaci\u00f3n de archivos en el sistema de archivos.</p> FileSystemStorageService.java<pre><code>@Service\npublic class FileSystemStorageService {\n    private final static String STORAGE_LOCATION = \"mediafile\";\n\n    @PostConstruct\n    public void init() {\n        try {\n            Files.createDirectories(Paths.get(STORAGE_LOCATION));\n        } catch (IOException e) {\n            throw new RuntimeException(\"Could not initialize storage location\", e);\n        }\n    }\n\n    public String store(MultipartFile file) {\n        String originalFilename = file.getOriginalFilename();\n        String filename = UUID.randomUUID() + \".\" + StringUtils.getFilenameExtension(originalFilename);\n\n        if (file.isEmpty()) {\n            throw new RuntimeException(\"Failed to store empty file \" + filename);\n        }\n\n        try {\n            InputStream inputStream = file.getInputStream();\n            Files.copy(inputStream, Paths.get(STORAGE_LOCATION).resolve(filename), StandardCopyOption.REPLACE_EXISTING);\n        } catch (IOException e) {\n            throw new RuntimeException(\"Failed to store file \" + filename, e);\n        }\n        return filename;\n    }\n\n    public Path load(String filename) {\n        return Paths.get(STORAGE_LOCATION).resolve(filename);\n    }\n\n    public Resource loadAsResource(String filename) {\n        try {\n            Path file = load(filename);\n            Resource resource = new UrlResource(file.toUri());\n            if (resource.exists() || resource.isReadable()) {\n                return resource;\n            } else {\n                throw new ResourceNotFoundException(\"Could not read file: \" + filename);\n            }\n        } catch (MalformedURLException e) {\n            throw new ResourceNotFoundException(\"Could not read file: \" + filename, e);\n        }\n    }\n\n    public void delete(String filename) {\n        Path file = load(filename);\n        try {\n            FileSystemUtils.deleteRecursively(file);\n        } catch (IOException e) {\n        }\n    }\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1-3:</p> <ul> <li><code>@Service</code>: Indica que esta clase es un servicio Spring y ser\u00e1 gestionada por el contenedor de Spring.</li> <li><code>STORAGE_LOCATION</code>: Constante que define la ubicaci\u00f3n en el sistema de archivos donde se almacenar\u00e1n los archivos subidos.</li> </ul> </li> <li> <p>L\u00ednea 5-6:</p> <ul> <li><code>@PostConstruct</code>: Anotaci\u00f3n que indica que este m\u00e9todo debe ejecutarse despu\u00e9s de la inyecci\u00f3n de dependencias para realizar la inicializaci\u00f3n.</li> <li><code>init()</code>: M\u00e9todo que crea el directorio de almacenamiento si no existe, lanzando una excepci\u00f3n si no se puede crear.</li> </ul> </li> <li> <p>L\u00ednea 14-29:</p> <ul> <li><code>store(MultipartFile file)</code>: M\u00e9todo que almacena un archivo subido.<ul> <li><code>MultipartFile file</code>: Representa el archivo subido.</li> <li><code>String originalFilename = file.getOriginalFilename();</code>: Obtiene el nombre original del archivo.</li> <li><code>String filename = UUID.randomUUID() + \".\" + StringUtils.getFilenameExtension(originalFilename);</code>: Genera un nombre \u00fanico para el archivo usando UUID y mantiene la extensi\u00f3n original.</li> <li><code>if (file.isEmpty()) { ... }</code>: Verifica si el archivo est\u00e1 vac\u00edo y lanza una excepci\u00f3n si es as\u00ed.</li> <li><code>try { ... } catch (IOException e) { ... }</code>: Copia el archivo al directorio de almacenamiento, reemplazando cualquier archivo existente con el mismo nombre.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 31-33:</p> <ul> <li><code>load(String filename)</code>: M\u00e9todo que construye la ruta completa del archivo especificado.</li> <li><code>String filename</code>: Nombre del archivo a cargar.</li> <li><code>Paths.get(STORAGE_LOCATION).resolve(filename);</code>: Resuelve el nombre del archivo contra el directorio de almacenamiento para obtener la ruta completa.</li> </ul> </li> <li> <p>L\u00ednea 35-47:</p> <ul> <li><code>loadAsResource(String filename)</code>: M\u00e9todo que carga un archivo como recurso.</li> <li><code>Path file = load(filename);</code>: Obtiene la ruta del archivo.</li> <li><code>Resource resource = new UrlResource(file.toUri());</code>: Crea un recurso a partir de la URI del archivo.</li> <li><code>if (resource.exists() || resource.isReadable()) { ... }</code>: Verifica si el recurso existe y es legible.</li> <li><code>catch (MalformedURLException e) { ... }</code>: Captura y maneja excepciones de URL mal formadas.</li> </ul> </li> <li> <p>L\u00ednea 49-55:</p> <ul> <li><code>delete(String filename)</code>: M\u00e9todo que elimina un archivo especificado.</li> <li><code>Path file = load(filename);</code>: Obtiene la ruta del archivo.</li> <li><code>FileSystemUtils.deleteRecursively(file);</code>: Elimina el archivo y lanza una excepci\u00f3n si falla.</li> </ul> </li> </ul>"},{"location":"get-book/#excepcion-personalizada-resourcenotfoundexception","title":"Excepci\u00f3n Personalizada ResourceNotFoundException","text":"<p>La clase <code>ResourceNotFoundException</code> es una excepci\u00f3n personalizada que se utiliza para indicar que un recurso solicitado no fue encontrado. Esta clase extiende <code>RuntimeException</code> y est\u00e1 anotada con <code>@ResponseStatus</code> para que, cuando sea lanzada, el servidor retorne un estado <code>HTTP 404 Not Found</code>.</p>"},{"location":"get-book/#implementacion-de-resourcenotfoundexception","title":"Implementaci\u00f3n de ResourceNotFoundException","text":"ResourceNotFoundException.java<pre><code>@ResponseStatus(HttpStatus.NOT_FOUND)\npublic class ResourceNotFoundException extends RuntimeException {\n    // Constructor sin argumentos\n    public ResourceNotFoundException() {\n        super();\n    }\n\n    // Constructor que acepta un mensaje\n    public ResourceNotFoundException(String message) {\n        super(message);\n    }\n\n    // Constructor que acepta un mensaje y una causa\n    public ResourceNotFoundException(String message, Throwable throwable) {\n        super(message, throwable);\n    }\n}\n</code></pre>"},{"location":"get-book/#descripcion-de-la-implementacion","title":"Descripci\u00f3n de la Implementaci\u00f3n","text":"<ol> <li> <p>Anotaci\u00f3n @ResponseStatus(HttpStatus.NOT_FOUND):</p> <ul> <li>Esta anotaci\u00f3n indica que cuando esta excepci\u00f3n es lanzada, el servidor debe responder con un estado <code>HTTP 404 Not Found</code>. Es una forma conveniente de asociar un c\u00f3digo de estado HTTP espec\u00edfico con una excepci\u00f3n.</li> </ul> </li> <li> <p>Extensi\u00f3n de RuntimeException:</p> <ul> <li>La clase extiende <code>RuntimeException</code>, lo que la convierte en una excepci\u00f3n no comprobada (unchecked exception). Esto significa que no es obligatorio manejarla expl\u00edcitamente en el c\u00f3digo mediante bloques <code>try-catch</code>.</li> </ul> </li> </ol> <p>L\u00ednea 4-6:</p> <pre><code>public ResourceNotFoundException() {\n    super();\n}\n</code></pre> <ul> <li>Este es un constructor por defecto que llama al constructor sin argumentos de la clase <code>RuntimeException</code>. Se utiliza cuando no se desea proporcionar un mensaje o causa espec\u00edfica para la excepci\u00f3n.</li> </ul> <p>L\u00ednea 9-11:</p> <pre><code>public ResourceNotFoundException(String message) {\n    super(message);\n}\n</code></pre> <ul> <li>Este constructor permite crear una instancia de la excepci\u00f3n con un mensaje descriptivo que proporciona m\u00e1s informaci\u00f3n sobre el motivo de la excepci\u00f3n. El mensaje se pasa al constructor de la superclase <code>RuntimeException</code>.</li> </ul> <p>L\u00ednea 14-16:</p> <pre><code>public ResourceNotFoundException(String message, Throwable throwable) {\n    super(message, throwable);\n}\n</code></pre> <ul> <li>Este constructor permite crear una instancia de la excepci\u00f3n con un mensaje descriptivo y una causa subyacente (<code>Throwable</code>). La causa representa la excepci\u00f3n original que provoc\u00f3 esta excepci\u00f3n y se pasa junto con el mensaje al constructor de la superclase <code>RuntimeException</code>.</li> </ul>"},{"location":"get-book/#controlador-para-la-subida-y-recuperacion-de-archivos","title":"Controlador para la Subida y Recuperaci\u00f3n de Archivos","text":""},{"location":"get-book/#crear-la-clase-filecontroller","title":"Crear la Clase FileController","text":"<p>La clase <code>FileController</code> maneja las solicitudes HTTP relacionadas con la subida y recuperaci\u00f3n de archivos.</p> FileController.java<pre><code>import org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.*;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.util.Map;\n\n@RestController\n@RequestMapping(\"/api/files\")\npublic class FileController {\n\n    @Autowired\n    private FileSystemStorageService storageService;\n\n    @PostMapping(\"/upload\")\n    public Map&lt;String, String&gt; upload(@RequestParam(\"file\") MultipartFile multipartFile) {\n        String path = storageService.store(multipartFile);\n        return Map.of(\"path\", path);\n    }\n\n    @GetMapping(\"/{filename}\")\n    public ResponseEntity&lt;Resource&gt; getResource(@PathVariable String filename) throws IOException {\n        Resource resource = storageService.loadAsResource(filename);\n        String contentType = Files.probeContentType(resource.getFile().toPath());\n\n        return ResponseEntity.ok().header(HttpHeaders.CONTENT_TYPE, contentType).body(resource);\n    }\n}\n</code></pre> <ul> <li>L\u00ednea 12-13:</li> </ul> <pre><code>@RestController\n@RequestMapping(\"/api/files\")\npublic class FileController {\n</code></pre> <ul> <li><code>@RestController</code>: Anotaci\u00f3n que indica que esta clase es un controlador REST y que los m\u00e9todos de la clase devolver\u00e1n datos directamente en lugar de vistas.</li> <li><code>@RequestMapping(\"/api/files\")</code>: Establece la ruta base para todas las solicitudes manejadas por este controlador. Todas las rutas comenzar\u00e1n con <code>/api/files</code>.</li> </ul> <p>Inyecci\u00f3n de Dependencias</p> <pre><code>@Autowired\nprivate FileSystemStorageService storageService;\n</code></pre> <ul> <li><code>@Autowired</code>: Inyecta una instancia del servicio FileSystemStorageService en el controlador. Este servicio se utilizar\u00e1 para manejar las operaciones de almacenamiento de archivos.</li> </ul> <p>M\u00e9todo upload</p> <pre><code>@PostMapping(\"/upload\")\npublic Map&lt;String, String&gt; upload(@RequestParam(\"file\") MultipartFile multipartFile) {\n    String path = storageService.store(multipartFile);\n    return Map.of(\"path\", path);\n}\n</code></pre> <ul> <li><code>@PostMapping(\"/upload\")</code>: Mapea las solicitudes HTTP POST a la ruta <code>/upload</code> a este m\u00e9todo.</li> <li><code>@RequestParam(\"file\") MultipartFile multipartFile</code>: Captura el archivo subido desde la solicitud. El archivo debe estar en el campo de formulario con el nombre file.</li> <li><code>String path = storageService.store(multipartFile);</code>: Utiliza el servicio FileSystemStorageService para almacenar el archivo y obtener la ruta del archivo almacenado.</li> <li><code>return Map.of(\"path\", path);</code>: Devuelve un mapa con la ruta del archivo almacenado.</li> </ul> <p>M\u00e9todo getResource</p> <pre><code>@GetMapping(\"/{filename}\")\npublic ResponseEntity&lt;Resource&gt; getResource(@PathVariable String filename) throws IOException {\n    Resource resource = storageService.loadAsResource(filename);\n    String contentType = Files.probeContentType(resource.getFile().toPath());\n    return ResponseEntity.ok().header(HttpHeaders.CONTENT_TYPE, contentType).body(resource);\n}\n</code></pre> <ul> <li><code>@GetMapping(\"/{filename}\")</code>: Mapea las solicitudes HTTP GET a la ruta /api/files/{filename} a este m\u00e9todo.</li> <li><code>@PathVariable String filename</code>: Captura el nombre del archivo de la ruta de la solicitud.</li> <li><code>Resource resource = storageService.loadAsResource(filename);</code>: Utiliza el servicio FileSystemStorageService para cargar el archivo como un recurso.</li> <li><code>String contentType = Files.probeContentType(resource.getFile().toPath());</code>: Determina el tipo de contenido del archivo.</li> <li><code>return ResponseEntity.ok().header(HttpHeaders.CONTENT_TYPE, contentType).body(resource);</code>: Devuelve el recurso en la respuesta HTTP con el tipo de contenido adecuado.</li> </ul>"},{"location":"get-book/#probar-endpoint-subir-archivo","title":"Probar Endpoint Subir Archivo","text":""},{"location":"get-book/#problema-inicial","title":"Problema Inicial","text":"<p>Al intentar subir un archivo utilizando el endpoint <code>upload</code>, observamos que el archivo no se puede subir debido a una limitaci\u00f3n de tama\u00f1o.</p> <p>En la imagen siguiente, podemos ver que se obtiene un estado <code>413 Request Entity Too Large</code> al intentar subir el archivo:</p> <p></p>"},{"location":"get-book/#diagnostico-del-problema","title":"Diagn\u00f3stico del Problema","text":"<p>El error <code>413 Request Entity Too Large</code> indica que el tama\u00f1o del archivo excede el l\u00edmite permitido por el servidor. Podemos confirmar esto revisando la consola del IDE, donde se muestra un mensaje que hace referencia a que el tama\u00f1o m\u00e1ximo permitido ha sido excedido:</p> <p></p>"},{"location":"get-book/#solucion","title":"Soluci\u00f3n","text":"<p>Para resolver este problema, necesitamos incrementar el tama\u00f1o m\u00e1ximo permitido para los archivos subidos. Esto se puede hacer configurando las propiedades en el archivo <code>application.properties</code> de nuestro proyecto Spring Boot.</p>"},{"location":"get-book/#incrementar-el-tamano-maximo-de-los-archivos-subidos","title":"Incrementar el Tama\u00f1o M\u00e1ximo de los Archivos Subidos","text":"<p>Para permitir la subida de archivos m\u00e1s grandes, configuramos el tama\u00f1o m\u00e1ximo de los archivos en <code>application.properties</code> de la siguiente manera:</p> application.properties<pre><code>spring.servlet.multipart.max-file-size=100MB\nspring.servlet.multipart.max-request-size=100MB\n</code></pre> <ul> <li><code>spring.servlet.multipart.max-file-size=100MB</code>: Establece el tama\u00f1o m\u00e1ximo permitido para un archivo subido a 100MB.</li> <li><code>spring.servlet.multipart.max-request-size=100MB</code>: Establece el tama\u00f1o m\u00e1ximo permitido para una solicitud multipart a 100MB.</li> </ul>"},{"location":"get-book/#resultado-final","title":"Resultado Final","text":""},{"location":"get-book/#prueba-del-endpoint-post","title":"Prueba del Endpoint POST","text":"<p>Volvemos a realizar la prueba del endpoint para subir archivos despu\u00e9s de agregar la configuraci\u00f3n en <code>application.properties</code>.</p> <ol> <li>Configuraci\u00f3n de la Solicitud en Postman:<ul> <li>M\u00e9todo: POST</li> <li>URL: <code>http://localhost:8081/api/files/upload</code></li> <li>Body:<ul> <li>Selecciona la opci\u00f3n <code>form-data</code>.</li> <li>A\u00f1ade un campo con la clave <code>file</code>.</li> <li>En el valor, selecciona el archivo que deseas subir desde tu sistema local.</li> </ul> </li> </ul> </li> </ol> <p>Al enviar la solicitud, si todo est\u00e1 configurado correctamente, obtendr\u00e1s una respuesta con el estado <code>200 OK</code> y un JSON que indica la ruta donde se ha guardado el archivo. El resultado se ve as\u00ed en Postman:</p> <p></p> <ul> <li>Insercion de la imagen de la portada para el libro en formato <code>.jpg</code></li> </ul> <p></p> <ul> <li>Explicaci\u00f3n del Uso de form-data:<ul> <li>form-data: Esta opci\u00f3n se utiliza para subir archivos y datos mixtos en una solicitud multipart. Es adecuada cuando necesitas enviar archivos junto con otros datos de formulario en una misma solicitud.</li> <li>Campo <code>file</code>: Este campo representa el archivo que se desea subir. En Postman, puedes seleccionar un archivo de tu sistema local para enviarlo con la solicitud.</li> </ul> </li> </ul>"},{"location":"get-book/#prueba-del-endpoint-get","title":"Prueba del Endpoint GET","text":"<p>Para asegurarnos de que el archivo se ha subido correctamente, realizamos una prueba para consultar el archivo subido.</p> <ol> <li>Configuraci\u00f3n de la Solicitud en Postman:<ul> <li>M\u00e9todo: GET</li> <li>URL: <code>http://localhost:8081/api/files/{fileName}</code><ul> <li>Reemplaza <code>{fileName}</code> con el nombre del archivo devuelto en la respuesta del endpoint de subida. Por ejemplo: <code>8700404e-404e-429f-a3f1-fb029be470a.pdf</code>.</li> </ul> </li> </ul> </li> </ol> <p>Al enviar la solicitud, si el archivo existe, obtendr\u00e1s una respuesta con el estado <code>200 OK</code> y el archivo se mostrar\u00e1 en el cuerpo de la respuesta. El resultado se ve as\u00ed en Postman:</p> <p></p> <p>Con estas pruebas, hemos verificado que los endpoints para subir y consultar archivos funcionan correctamente, y hemos explicado detalladamente c\u00f3mo configurar y ejecutar estas pruebas en Postman.</p>"},{"location":"get-book/#conlusion","title":"Conlusi\u00f3n","text":"<p>En esta sesi\u00f3n, hemos recorrido los pasos necesarios para crear una aplicaci\u00f3n completa de Spring Boot con funcionalidades avanzadas y buenas pr\u00e1cticas. Desde la creaci\u00f3n del proyecto, adicionar dependencias, configuraci\u00f3n del entorno de desarrollo con Docker Compose, creaci\u00f3n de la entidad, validaci\u00f3n de la entidad, creaci\u00f3n del repositorio, creaci\u00f3n del DTO, validaciones, creaci\u00f3n del servicio, creaci\u00f3n de mapper, creaci\u00f3n del controlador, entre otros.</p> <p>Con estos pasos, hemos construido una aplicaci\u00f3n robusta de Spring Boot, con soporte para manejo de entidades, repositorios, servicios, controladores, manejo de excepciones y funcionalidades avanzadas como la subida de archivos y configuraci\u00f3n de Docker Compose. Este conocimiento te permitir\u00e1 desarrollar aplicaciones eficientes y bien estructuradas con Spring Boot.</p>"},{"location":"get-code-http/","title":"C\u00f3digos de Estado HTTP","text":"<p>Los c\u00f3digos de estado HTTP son c\u00f3digos de respuesta est\u00e1ndar proporcionados por los servidores web en respuesta a una solicitud realizada al servidor. Estos c\u00f3digos ayudan a los clientes (como navegadores web o aplicaciones) a entender el resultado de la solicitud. Aqu\u00ed est\u00e1n los c\u00f3digos de estado HTTP m\u00e1s comunes que se utilizan en una API.</p>"},{"location":"get-code-http/#codigo-de-estado-200-ok","title":"C\u00f3digo de Estado 200 (OK)","text":"<ul> <li>Descripci\u00f3n: La solicitud ha tenido \u00e9xito.</li> <li>Uso: Se utiliza cuando una solicitud GET, PUT o DELETE ha sido procesada correctamente. Tambi\u00e9n puede usarse en una solicitud POST que no crea un nuevo recurso.</li> <li>Ejemplo:<ul> <li>Recuperar una lista de libros.</li> <li>Actualizar la informaci\u00f3n de un libro existente.</li> </ul> </li> </ul> <pre><code>@GetMapping(\"/books\")\npublic ResponseEntity&lt;List&lt;Book&gt;&gt; getAllBooks() {\n    List&lt;Book&gt; books = bookService.findAll();\n    return new ResponseEntity&lt;&gt;(books, HttpStatus.OK);\n}\n</code></pre>"},{"location":"get-code-http/#codigo-de-estado-201-created","title":"C\u00f3digo de Estado 201 (Created)","text":"<ul> <li>Descripci\u00f3n: La solicitud ha sido cumplida y ha resultado en la creaci\u00f3n de un nuevo recurso.</li> <li>Uso: Se utiliza en una solicitud POST que crea un nuevo recurso.</li> <li>Ejemplo:<ul> <li>Crear un nuevo libro.</li> </ul> </li> </ul> <pre><code>@PostMapping(\"/books\")\npublic ResponseEntity&lt;Book&gt; createBook(@RequestBody @Valid Book book) {\n    Book createdBook = bookService.save(book);\n    return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.CREATED);\n}\n</code></pre>"},{"location":"get-code-http/#codigo-de-estado-400-bad-request","title":"C\u00f3digo de Estado 400 (Bad Request)","text":"<ul> <li>Descripci\u00f3n: El servidor no puede procesar la solicitud debido a algo que es percibido como un error del cliente (por ejemplo, datos de solicitud mal formados).</li> <li>Uso: Se utiliza cuando la solicitud enviada al servidor tiene errores de validaci\u00f3n o est\u00e1 mal formada.</li> <li>Ejemplo: Enviar datos incompletos o inv\u00e1lidos al crear o actualizar un recurso.</li> </ul> <p>Utilizando anotaciones de validaci\u00f3n en el DTO para asegurar que los datos proporcionados sean correctos.</p> <pre><code>import jakarta.validation.constraints.DecimalMin;\nimport jakarta.validation.constraints.NotEmpty;\nimport jakarta.validation.constraints.NotNull;\n\npublic record Book(\n        String id,\n        @NotEmpty(message = \"Book code is required\") String code,\n        @NotEmpty(message = \"Book name is required\") String name,\n        String description,\n        @NotNull(message = \"Book price is required\") @DecimalMin(\"0.1\") BigDecimal price,\n        @NotBlank String imageUrl,\n        @NotBlank String filePath) {}\n</code></pre> <p>En el controlador, utilizamos <code>@Valid</code> para activar la validaci\u00f3n.</p> <pre><code>@PostMapping(\"/books\")\npublic ResponseEntity&lt;Book&gt; createBook(@RequestBody @Valid Book book) {\n    Book createdBook = bookService.save(book);\n    return new ResponseEntity&lt;&gt;(createdBook, HttpStatus.CREATED);\n}\n</code></pre>"},{"location":"get-code-http/#codigo-de-estado-404-not-found","title":"C\u00f3digo de Estado 404 (Not Found)","text":"<ul> <li>Descripci\u00f3n: El servidor no puede encontrar el recurso solicitado.</li> <li>Uso: Se utiliza cuando un recurso espec\u00edfico no se encuentra en el servidor.</li> <li>Ejemplo:<ul> <li>Intentar recuperar un libro que no existe.</li> <li>Refactorizando el servicio para lanzar <code>BookNotFoundException</code>.</li> </ul> </li> </ul> <pre><code>@Service\npublic class BookService {\n\n    @Autowired\n    private BookRepository bookRepository;\n\n    public Book getBookByCode(String code) {\n        Optional&lt;BookEntity&gt; bookEntity = bookRepository.findByCode(code);\n        if (bookEntity.isEmpty()) {\n            throw new BookNotFoundException(\"Book with code \" + code + \" not found\");\n        }\n        return BookMapper.toBook(bookEntity.get());\n    }\n}\n</code></pre>"},{"location":"get-code-http/#codigo-de-estado-500-internal-server-error","title":"C\u00f3digo de Estado 500 (Internal Server Error)","text":"<ul> <li>Descripci\u00f3n: El servidor ha encontrado una situaci\u00f3n que no sabe c\u00f3mo manejar.</li> <li>Uso: Se utiliza cuando ocurre un error inesperado en el servidor.</li> <li>Ejemplo:<ul> <li>Fallo en el servidor debido a una excepci\u00f3n no manejada.</li> </ul> </li> </ul> <p>Manejo de excepciones en el servicio y lanzamiento de <code>InternalServerErrorException</code>.</p> <pre><code>@Service\npublic class BookService {\n\n    @Autowired\n    private BookRepository bookRepository;\n\n    public List&lt;Book&gt; findAll() {\n        try {\n            List&lt;BookEntity&gt; bookEntities = bookRepository.findAll();\n            return bookEntities.stream().map(BookMapper::toBook).toList();\n        } catch (Exception e) {\n            throw new InternalServerErrorException(\"Failed to retrieve books\");\n        }\n    }\n}\n</code></pre>"},{"location":"get-code-http/#conlusion","title":"Conlusi\u00f3n","text":"<p>En esta sesi\u00f3n, hemos mostrado qu\u00e9 significan los c\u00f3digos HTTP m\u00e1s usados en una aplicaci\u00f3n completa de Spring Boot, abarcando desde la configuraci\u00f3n inicial hasta funcionalidades avanzadas. Hemos cubierto la creaci\u00f3n de entidades, repositorios, servicios, controladores y validaciones. Adem\u00e1s, hemos manejado correctamente los c\u00f3digos de estado HTTP: 200 (OK), 201 (Created), 400 (Bad Request), 404 (Not Found) y 500 (Internal Server Error).</p> <p>Con estos pasos, hemos construido una aplicaci\u00f3n robusta y bien estructurada, que te permitir\u00e1 desarrollar proyectos eficientes con Spring Boot.</p>"},{"location":"get-code-http/#enlace-de-retorno","title":"Enlace de Retorno","text":"<p>Regresar a la documentaci\u00f3n del libro.</p>"},{"location":"get-order/","title":"Creaci\u00f3n de Entidades Order e Item","text":""},{"location":"get-order/#introduccion","title":"Introducci\u00f3n","text":"<p>En esta secci\u00f3n del taller, vamos a crear tres clases fundamentales para gestionar \u00f3rdenes de venta y los \u00edtems asociados a estas \u00f3rdenes en nuestro sistema: <code>SalesOrderEntity</code>, <code>SalesOrderItemEntity</code>, y <code>PaymentStatus</code>. Estas clases nos permitir\u00e1n manejar de forma estructurada y eficiente la informaci\u00f3n relacionada con las ventas y sus detalles.</p>"},{"location":"get-order/#1-entidad-sales-order","title":"1. Entidad Sales Order","text":""},{"location":"get-order/#descripcion","title":"Descripci\u00f3n","text":"<p>La clase <code>SalesOrderEntity</code> representa una orden en nuestro sistema, que incluye el total de la orden, el estado del pago y los \u00edtems asociados a esa orden. Esta entidad es esencial para mantener un registro completo y detallado de cada venta realizada.</p> <ul> <li> <p>Propiedades de SalesOrderEntity</p> <ul> <li>ID: Identificador \u00fanico de la orden.</li> <li>Total: Monto total de la orden.</li> <li>Estado del Pago: Indica si el pago ha sido completado, est\u00e1 pendiente, etc.</li> <li>Fecha de Creaci\u00f3n: Fecha en la que se cre\u00f3 la orden.</li> <li>Cliente: Referencia a la entidad UserEntity que representa al cliente que realiz\u00f3 la orden.</li> <li>\u00cdtems: Lista de \u00edtems incluidos en la orden.</li> </ul> </li> <li> <p>Importancia La entidad <code>SalesOrderEntity</code> es crucial porque nos permite:</p> <ul> <li>Rastrear Ventas: Registrar cada venta realizada, incluyendo detalles como el monto total y el estado del pago.</li> <li>Generar Informes: Proporcionar datos que pueden ser utilizados para generar informes de ventas y an\u00e1lisis financieros.</li> <li>Gestionar Pedidos: Facilitar la gesti\u00f3n de pedidos, permitiendo a los administradores ver el estado y los detalles de cada orden.</li> </ul> </li> </ul> SalesOrderEntity.java<pre><code>import com.jconfdominicana.bookstore.model.enums.PaymentStatus;\nimport jakarta.persistence.CascadeType;\nimport jakarta.persistence.Entity;\nimport jakarta.persistence.EnumType;\nimport jakarta.persistence.Enumerated;\nimport jakarta.persistence.FetchType;\nimport jakarta.persistence.GeneratedValue;\nimport jakarta.persistence.GenerationType;\nimport jakarta.persistence.Id;\nimport jakarta.persistence.JoinColumn;\nimport jakarta.persistence.ManyToOne;\nimport jakarta.persistence.OneToMany;\nimport jakarta.persistence.SequenceGenerator;\nimport jakarta.persistence.Table;\nimport java.math.BigDecimal;\nimport java.time.LocalDateTime;\nimport java.util.List;\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.Setter;\n\n@Entity\n@Table(name = \"sales_orders\")\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class SalesOrderEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sales_order_id_generator\")\n    @SequenceGenerator(name = \"sales_order_id_generator\", sequenceName = \"sales_order_id_seq\")\n    private Long id;\n\n    private BigDecimal total;\n\n    @Enumerated(EnumType.STRING)\n    private PaymentStatus paymentStatus;\n\n    private LocalDateTime createdAt;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"customer_id\", referencedColumnName = \"id\", nullable = false)\n    private UserEntity customer;\n\n    @OneToMany(mappedBy = \"salesOrderEntity\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)\n    private List&lt;SalesOrderItemEntity&gt; items;\n}\n</code></pre> <ul> <li> <p>L\u00ednea 39:</p> <ul> <li><code>@Enumerated(EnumType.STRING)</code>: Especifica que el campo paymentStatus es un enumerado y se almacenar\u00e1 como una cadena en la base de datos.</li> </ul> </li> <li> <p>L\u00ednea 44-46:</p> <ul> <li><code>@ManyToOne</code>: Esta anotaci\u00f3n indica que existe una relaci\u00f3n de muchos a uno entre <code>OrderEntity</code> y <code>User</code>. En t\u00e9rminos de base de datos, esto significa que muchas \u00f3rdenes pueden estar asociadas con un solo usuario. Esta relaci\u00f3n permite que una orden est\u00e9 vinculada a un \u00fanico cliente.</li> <li><code>@JoinColumn(name = \"customer_id\", referencedColumnName = \"id\", nullable = false)</code>: Especifica la columna de uni\u00f3n para la relaci\u00f3n con <code>UserEntity</code>. La columna <code>customer_id</code> en <code>SalesOrderEntity</code> se refiere a la columna <code>id</code> en <code>UserEntity</code> y es obligatoria (<code>nullable = false</code>).</li> </ul> </li> <li> <p>L\u00ednea 48-49:</p> <ul> <li><code>@OneToMany(mappedBy = \"salesOrderEntity\", cascade = CascadeType.ALL, fetch = FetchType.LAZY)</code>: Indica una relaci\u00f3n de uno a muchos con <code>SalesOrderItemEntity</code>. La propiedad <code>mappedBy</code> se refiere al campo <code>salesOrderEntity</code> en <code>SalesOrderItemEntity</code>, <code>cascade = CascadeType.ALL</code> indica que todas las operaciones de persistencia se propagar\u00e1n a los elementos relacionados, y <code>fetch = FetchType.LAZY</code> indica que la relaci\u00f3n se cargar\u00e1 de manera perezosa.</li> </ul> </li> <li> <p>Lombok Annotations:</p> <ul> <li><code>@Getter</code>: Genera autom\u00e1ticamente m\u00e9todos getter para todos los campos.</li> <li><code>@Setter</code>: Genera autom\u00e1ticamente m\u00e9todos setter para todos los campos.</li> <li><code>@AllArgsConstructor</code>: Genera un constructor con un argumento para cada campo en la clase.</li> <li><code>@NoArgsConstructor</code>: Genera un constructor sin argumentos.</li> <li><code>@Builder</code>: Permite construir objetos de esta clase de manera fluida.</li> </ul> </li> </ul>"},{"location":"get-order/#2-enumerado-paymentstatus","title":"2. Enumerado PaymentStatus","text":""},{"location":"get-order/#descripcion_1","title":"Descripci\u00f3n","text":"<p>La enumeraci\u00f3n <code>PaymentStatus</code> define los posibles estados de pago para una orden. Esto nos permite estandarizar y controlar los valores que representan el estado del pago.</p> <p>Valores de <code>PaymentStatus</code></p> <ul> <li>PENDING: El pago est\u00e1 pendiente.</li> <li>PAID: El pago ha sido completado.</li> </ul> PaymentStatus.java<pre><code>public enum PaymentStatus {\n    PENDING,\n    PAID\n}\n</code></pre>"},{"location":"get-order/#3-entidad-sales-order-item","title":"3. Entidad Sales Order Item","text":""},{"location":"get-order/#descripcion_2","title":"Descripci\u00f3n","text":"<p>La clase <code>SalesOrderItemEntity</code> representa un \u00edtem individual dentro de una orden de venta. Cada \u00edtem est\u00e1 asociado a un producto espec\u00edfico y tiene propiedades como la cantidad y el precio.</p> <p>Propiedades de <code>SalesOrderItemEntity</code></p> <ul> <li>ID: Identificador \u00fanico del \u00edtem, generado mediante una secuencia.</li> <li>Precio: Precio del \u00edtem en la orden.</li> <li>Descargas Disponibles: N\u00famero de descargas disponibles para el \u00edtem, si aplica.</li> <li>Libro: Referencia a la entidad BookEntity que representa el libro asociado a este \u00edtem.</li> <li>Orden de Venta: Referencia a la orden de venta (SalesOrderEntity) a la que pertenece este \u00edtem.</li> </ul> <p>Importancia La entidad <code>SalesOrderItemEntity</code> es fundamental porque nos permite:</p> <ul> <li>Desglosar Ventas: Ver los detalles espec\u00edficos de cada producto vendido en una orden.</li> <li>Calcular Totales: Calcular el total de la orden sumando los precios de cada \u00edtem.</li> <li>Analizar Productos: Analizar qu\u00e9 productos se venden m\u00e1s y ajustar inventarios y estrategias de marketing en consecuencia.</li> </ul> SalesOrderItemEntity.java<pre><code>@Entity\n@Table(name = \"sales_order_items\")\n@Getter\n@Setter\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class SalesOrderItemEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"sales_order_items_id_generator\")\n    @SequenceGenerator(name = \"sales_order_items_id_generator\", sequenceName = \"sales_order_items_id_seq\")\n    private Long id;\n\n    private BigDecimal price;\n\n    @Column(name = \"downloads_available\")\n    private Integer downloadsAvailable;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"book_id\", referencedColumnName = \"id\")\n    private BookEntity bookEntity;\n\n    @JsonIgnore\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"order_id\", referencedColumnName = \"id\")\n    private SalesOrderEntity salesOrderEntity;\n}\n</code></pre> <ul> <li> <p>L\u00ednea 19-21:</p> <ul> <li><code>@ManyToOne(fetch = FetchType.LAZY)</code>: Indica una relaci\u00f3n de muchos a uno con <code>BookEntity</code>. La propiedad <code>fetch = FetchType.LAZY</code> indica que la relaci\u00f3n se cargar\u00e1 de manera perezosa.</li> <li><code>@JoinColumn(name = \"book_id\", referencedColumnName = \"id\")</code>: Especifica la columna de uni\u00f3n para la relaci\u00f3n con <code>BookEntity</code>. La columna <code>book_id</code> en <code>SalesOrderItemEntity</code> se refiere a la columna <code>id</code> en <code>BookEntity</code>.</li> </ul> </li> <li> <p>L\u00ednea 23-26:</p> <ul> <li><code>@JsonIgnore</code>: Anotaci\u00f3n de Jackson para ignorar esta propiedad durante la serializaci\u00f3n y deserializaci\u00f3n <code>JSON</code>, evitando posibles problemas de recursi\u00f3n infinita.</li> <li><code>@ManyToOne(fetch = FetchType.LAZY)</code>: Indica una relaci\u00f3n de muchos a uno con <code>SalesOrderEntity</code>. La propiedad <code>fetch = FetchType.LAZY</code> indica que la relaci\u00f3n se cargar\u00e1 de manera perezosa.</li> <li><code>@JoinColumn(name = \"order_id\", referencedColumnName = \"id\")</code>: Especifica la columna de uni\u00f3n para la relaci\u00f3n con <code>SalesOrderEntity</code>. La columna <code>order_id</code> en <code>SalesOrderItemEntity</code> se refiere a la columna <code>id</code> en <code>SalesOrderEntity</code>.</li> </ul> </li> </ul>"},{"location":"get-order/#creacion-de-schemas","title":"Creaci\u00f3n de Schemas","text":""},{"location":"get-order/#1-crear-la-secuencia-y-tabla-sales_orders","title":"1. Crear la secuencia y tabla sales_orders","text":"<ul> <li>Crear la Secuencia sales_order_id_seq</li> </ul> <pre><code>CREATE SEQUENCE sales_order_id_seq\n    START WITH 1\n    INCREMENT BY 50;\n</code></pre> <ul> <li><code>CREATE SEQUENCE sales_order_id_seq</code>: Crea una nueva secuencia llamada <code>sales_order_id_seq</code>. START WITH 1: La secuencia comienza en 1.</li> <li><code>INCREMENT BY 50</code>: La secuencia incrementa en 50 cada vez que se solicita un nuevo valor.</li> </ul>"},{"location":"get-order/#2-crear-la-tabla-sales_orders","title":"2. Crear la Tabla <code>sales_orders</code>","text":"<pre><code>CREATE TABLE sales_orders (\n    id BIGINT PRIMARY KEY DEFAULT nextval('sales_order_id_seq') NOT NULL,\n    total NUMERIC NOT NULL,\n    payment_status VARCHAR(255),\n    created_at TIMESTAMP NOT NULL,\n    customer_id BIGINT,\n    FOREIGN KEY (customer_id) REFERENCES users(id)\n);\n</code></pre> <ul> <li><code>id BIGINT PRIMARY KEY DEFAULT nextval('sales_order_id_seq') NOT NULL</code>:<ul> <li><code>id BIGINT PRIMARY KEY</code>: Define la columna <code>id</code> como la clave primaria de tipo BIGINT.</li> <li><code>DEFAULT nextval('sales_order_id_seq')</code>: El valor por defecto se obtiene de la secuencia <code>sales_order_id_seq</code>.</li> <li><code>NOT NULL</code>: El campo no puede ser nulo.</li> </ul> </li> <li><code>total NUMERIC NOT NULL</code>: Define la columna <code>total</code> como <code>NUMERIC</code> y no puede ser nula.</li> <li><code>payment_status VARCHAR(255)</code>: Define la columna <code>payment_status</code> como <code>VARCHAR(255)</code>.</li> <li><code>created_at TIMESTAMP NOT NULL</code>: Define la columna <code>created_at</code> como <code>TIMESTAMP</code> y no puede ser nula.</li> <li><code>customer_id BIGINT</code>: Define la columna <code>customer_id</code> como <code>BIGINT</code>.</li> <li><code>FOREIGN KEY (customer_id) REFERENCES users(id)</code>: Define <code>customer_id</code> como una clave for\u00e1nea que referencia a <code>id</code> en la tabla <code>users</code>.</li> </ul>"},{"location":"get-order/#3-crear-la-secuencia-y-tabla-sales_order_items","title":"3. Crear la secuencia y <code>tabla sales_order_items</code>","text":"<ul> <li>Crear la Secuencia sales_order_items_id_seq</li> </ul> <pre><code>CREATE SEQUENCE sales_order_items_id_seq\n    START WITH 1\n    INCREMENT BY 50;\n</code></pre> <ul> <li>Crear la Tabla sales_order_items</li> </ul> <pre><code>CREATE TABLE sales_order_items (\n    id INT DEFAULT nextval('sales_order_items_id_seq') PRIMARY KEY,\n    price NUMERIC,\n    downloads_available INT,\n    book_id BIGINT,\n    order_id BIGINT,\n    FOREIGN KEY (book_id) REFERENCES books(id),\n    FOREIGN KEY (order_id) REFERENCES sales_orders(id)\n);\n</code></pre> <ul> <li><code>id INT DEFAULT nextval('sales_order_items_id_seq') PRIMARY KEY</code>:<ul> <li><code>id INT PRIMARY KEY</code>: Define la columna id como la clave primaria de tipo INT.</li> <li><code>DEFAULT nextval('sales_order_items_id_seq')</code>: El valor por defecto se obtiene de la secuencia <code>sales_order_items_id_seq</code>.</li> <li><code>price NUMERIC</code>: Define la columna price como NUMERIC.</li> <li><code>downloads_available INT</code>: Define la columna downloads_available como INT.</li> <li><code>book_id BIGINT</code>: Define la columna book_id como BIGINT.</li> <li><code>order_id BIGINT</code>: Define la columna order_id como BIGINT.</li> <li><code>FOREIGN KEY (book_id) REFERENCES books(id)</code>: Define book_id como una clave for\u00e1nea que referencia a id en la tabla books.</li> <li><code>FOREIGN KEY (order_id) REFERENCES sales_orders(id)</code>: Define order_id como una clave for\u00e1nea que referencia a id en la tabla sales_orders.</li> </ul> </li> </ul>"},{"location":"get-order/#creacion-de-repositorios","title":"Creaci\u00f3n de Repositorios","text":"<p>En esta secci\u00f3n, vamos a detallar los repositorios <code>SalesOrderRepository</code> y <code>SalesOrderItemRepository</code> que proporcionan la interfaz para realizar operaciones CRUD (Crear, Leer, Actualizar, Eliminar) en las entidades <code>SalesOrderEntity</code> y <code>SalesOrderItemEntity</code>.</p>"},{"location":"get-order/#1-repositorio-salesorderrepository","title":"1. Repositorio SalesOrderRepository","text":"<p>El repositorio <code>SalesOrderRepository</code> proporciona m\u00e9todos para realizar operaciones CRUD en la entidad <code>SalesOrderEntity</code></p> SalesOrderRepository.java<pre><code>import org.springframework.data.jpa.repository.JpaRepository;\n\npublic interface SalesOrderRepository extends JpaRepository&lt;SalesOrderEntity, Long&gt; {\n}\n</code></pre> <ul> <li><code>public interface SalesOrderRepository extends JpaRepository&lt;SalesOrderEntity, Long&gt;</code>: Define una interfaz de repositorio que extiende <code>JpaRepository</code>. Esto proporciona autom\u00e1ticamente m\u00e9todos para realizar operaciones CRUD en la entidad <code>SalesOrderEntity</code>.<ul> <li><code>JpaRepository&lt;SalesOrderEntity, Long&gt;</code>: Especifica que el repositorio trabaja con la entidad SalesOrderEntity y utiliza Long como tipo de dato para la clave primaria.</li> <li>Los m\u00e9todos CRUD est\u00e1ndar que proporciona <code>JpaRepository</code> incluyen:<ul> <li><code>save(S entity)</code>: Guarda una entidad.</li> <li><code>findById(ID id)</code>: Encuentra una entidad por su ID.</li> <li><code>findAll()</code>: Encuentra todas las entidades.</li> <li><code>deleteById(ID id)</code>: Elimina una entidad por su ID.</li> </ul> </li> </ul> </li> </ul>"},{"location":"get-order/#2-repositorio-salesorderitemrepository","title":"2. Repositorio SalesOrderItemRepository","text":"<p>El repositorio <code>SalesOrderItemRepository</code> proporciona m\u00e9todos para realizar operaciones CRUD en la entidad <code>SalesOrderItemEntity</code>, as\u00ed como un m\u00e9todo adicional para encontrar un \u00edtem de una orden espec\u00edfica.</p> SalesOrderItemRepository.java<pre><code>import org.springframework.data.jpa.repository.JpaRepository;\nimport java.util.Optional;\n\npublic interface SalesOrderItemRepository extends JpaRepository&lt;SalesOrderItemEntity, Long&gt; {\n    Optional&lt;SalesOrderItemEntity&gt; findByIdAndSalesOrderEntity(Long id, SalesOrderEntity salesOrderEntity);\n}\n</code></pre> <ul> <li><code>Optional&lt;SalesOrderItemEntity&gt; findByIdAndSalesOrderEntity(Long id, SalesOrderEntity salesOrderEntity)</code>: M\u00e9todo adicional definido en el repositorio para encontrar un \u00edtem de una orden espec\u00edfica.<ul> <li><code>Optional&lt;SalesOrderItemEntity&gt; findByIdAndSalesOrderEntity(Long id, SalesOrderEntity salesOrderEntity)</code>: Encuentra un \u00edtem de una orden espec\u00edfica por su ID y la entidad de la orden a la que pertenece. Retorna un <code>Optional</code> que puede contener el \u00edtem encontrado o estar vac\u00edo si no se encuentra ning\u00fan \u00edtem que coincida con los criterios.<ul> <li><code>Long id</code>: El ID del \u00edtem de la orden.</li> <li><code>SalesOrderEntity salesOrderEntity</code>: La entidad de la orden a la que pertenece el \u00edtem.</li> </ul> </li> </ul> </li> </ul>"},{"location":"get-order/#creacion-del-servicio-salesorderservice","title":"Creaci\u00f3n del Servicio SalesOrderService","text":"<p>El servicio <code>SalesOrderService</code> se encarga de la l\u00f3gica de negocio relacionada con las \u00f3rdenes de venta en la aplicaci\u00f3n. Proporciona m\u00e9todos para crear una nueva orden y para recuperar \u00f3rdenes existentes.</p> <ul> <li>Servicio <code>SalesOrderService</code></li> </ul> SalesOrderService.java<pre><code>@Service\n@Transactional\npublic class SalesOrderService {\n\n    private final BookRepository bookRepository;\n\n    private final SalesOrderRepository orderRepository;\n\n    public SalesOrderService(BookRepository bookRepository, SalesOrderRepository orderRepository) {\n        this.bookRepository = bookRepository;\n        this.orderRepository = orderRepository;\n    }\n\n    public SalesOrderEntity createOrder(List&lt;Long&gt; bookIds){\n        SalesOrderEntity salesOrderEntity = new SalesOrderEntity();\n        List&lt;SalesOrderItemEntity&gt; items =  new ArrayList&lt;&gt;();\n        BigDecimal total = BigDecimal.ZERO;\n        for( Long bookId : bookIds) {\n            BookEntity book = bookRepository\n                    .findById(bookId)\n                    .orElseThrow(() -&gt; new BookNotFoundException(\"Book not found with id: \" + bookId));\n\n            SalesOrderItemEntity salesOrderItem = new SalesOrderItemEntity();\n            salesOrderItem.setBookEntity(book);\n            salesOrderItem.setPrice(book.getPrice());\n            salesOrderItem.setDownloadsAvailable(3);\n            salesOrderItem.setSalesOrderEntity(salesOrderEntity);\n\n            items.add(salesOrderItem);\n            total = total.add(salesOrderItem.getPrice());\n        }\n        salesOrderEntity.setPaymentStatus(PaymentStatus.PENDING);\n        salesOrderEntity.setCreatedAt(LocalDateTime.now());\n        salesOrderEntity.setTotal(total);\n        salesOrderEntity.setItems(items);\n\n        return orderRepository.save(salesOrderEntity);\n    }\n\n}\n</code></pre> <ul> <li> <p>L\u00ednea 2:</p> <ul> <li><code>@Transactional</code>: Asegura que todos los m\u00e9todos en esta clase se ejecuten dentro de una transacci\u00f3n. Si alguna parte del m\u00e9todo falla, se realiza un rollback de todas las operaciones de la base de datos realizadas en ese m\u00e9todo.</li> </ul> </li> <li> <p>L\u00ednea 14-38:</p> <ul> <li><code>createOrder(List&lt;Long&gt; bookIds)</code>: M\u00e9todo para crear una nueva orden de venta.</li> <li><code>SalesOrderEntity salesOrderEntity = new SalesOrderEntity();</code>: Crea una nueva instancia de <code>SalesOrderEntity</code>.</li> <li><code>List&lt;SalesOrderItemEntity&gt; items = new ArrayList&lt;&gt;();</code>: Inicializa una lista de \u00edtems de la orden.</li> <li><code>BigDecimal total = BigDecimal.ZERO;</code>: Inicializa el total de la orden en cero.</li> <li><code>Bucle for</code>: Itera sobre los IDs de los libros proporcionados para crear \u00edtems de la orden.<ul> <li><code>BookEntity book = bookRepository.findById(bookId).orElseThrow(...);</code>: Busca el libro por su <code>ID</code> o lanza una excepci\u00f3n si no se encuentra.</li> <li><code>SalesOrderItemEntity salesOrderItem = new SalesOrderItemEntity();</code>: Crea una nueva instancia de <code>SalesOrderItemEntity</code>.</li> <li><code>Setters</code>: Asigna los valores correspondientes al \u00edtem de la orden.</li> <li><code>items.add(salesOrderItem);</code>: A\u00f1ade el \u00edtem a la lista de \u00edtems.</li> <li><code>total = total.add(salesOrderItem.getPrice());</code>: Actualiza el total de la orden.</li> </ul> </li> <li><code>Setters</code>: Asigna valores a la orden de venta.</li> <li><code>return orderRepository.save(salesOrderEntity);</code>: Guarda la orden en la base de datos y retorna la entidad guardada.</li> </ul> </li> </ul>"},{"location":"get-order/#conlusion","title":"Conlusi\u00f3n","text":"<p>En esta sesi\u00f3n, hemos desarrollado una funcionalidad completa para la gesti\u00f3n de \u00f3rdenes de venta en una aplicaci\u00f3n Spring Boot. Desde la creaci\u00f3n de las entidades, la implementaci\u00f3n de repositorios y servicios, hasta la configuraci\u00f3n del controlador, hemos cubierto todos los componentes necesarios para una soluci\u00f3n robusta y bien estructurada. Con estos componentes, hemos construido una aplicaci\u00f3n Spring Boot s\u00f3lida y preparada para gestionar \u00f3rdenes de venta de manera eficaz, asegurando una arquitectura modular y escalable.</p>"},{"location":"get-user/","title":"PR\u00c1CTICA N\u00b0 1","text":""},{"location":"get-user/#crud-usuarios-con-postgresql","title":"CRUD USUARIOS \u2013 CON POSTGRESQL","text":"<ul> <li>Crear una clase llamada <code>User</code> con los campos <code>id</code>, <code>firstName</code>, <code>lastName</code>, <code>email</code>, <code>phone</code>, <code>password</code>, <code>role</code>, <code>createdAt</code> y <code>updatedAt</code> .</li> </ul> <pre><code>public class User {\n    private Long id;\n    private String firstName;\n    private String lastName;\n    private String email;\n    private String phone;\n    private String password;\n    private Role role;\n    private LocalDateTime createdAt = LocalDateTime.now();;\n    private LocalDateTime updatedAt;\n\n    // getters &amp; setters\n}\n</code></pre> <ol> <li>Convertir la clase User en una entidad de base de datos usando las anotaciones <code>@Entity</code>, <code>@Id</code>, <code>@GeneratedValue</code>.</li> <li>Crear su respectivo repositorio llamado <code>UserRepository</code> <ul> <li>Extender <code>JpaRepository&lt;User, Long&gt;</code>.</li> <li>Adicionar un m\u00e9todo que valide si existe el <code>email</code></li> </ul> </li> <li>Crear el schema por Flyway para la tabla <code>users</code>.<ul> <li>Definir la secuencia y la tabla en un archivo SQL de migraci\u00f3n.  </li> </ul> </li> <li>Crear el servicio <code>UserService</code> <ul> <li>Implementar la logica del negocio en el servicio <code>UserService</code>.</li> </ul> </li> <li>Crear el DTO <code>User</code><ul> <li>Definir el DTO para <code>User</code> junto a sus respectivas validaciones.</li> </ul> </li> <li>Crear el Mapper UserMapper<ul> <li>Implementar el mapeo entre <code>User</code> y <code>UserDTO</code>.  </li> </ul> </li> <li>Crear e implementar un controlador <code>UserController</code> <ul> <li>Manejar las operaciones CRUD de <code>User</code> a nivel de base de datos.</li> </ul> </li> <li>Probar la implementaci\u00f3n con POSTMAN.</li> </ol> <p>Finalmente, probar la implementaci\u00f3n realizando las siguientes operaciones con POSTMAN:</p> <ul> <li><code>GET</code> <code>/api/users</code> retorne la lista de usuarios. C\u00f3digos de respuesta: 200</li> <li><code>GET</code> <code>/api/users/{id}</code> retorne un usuario por id. C\u00f3digos de respuesta: 200 / 404</li> <li><code>POST</code> <code>/api/users</code> cree un nuevo usuario y lo retorne. C\u00f3digos de respuesta: 201 / 400</li> <li><code>PUT</code> <code>/api/users/{id}</code> actualice un usuario por id y lo retorne. C\u00f3digos de respuesta: 200 / 400 / 404</li> <li><code>DELETE</code> <code>/api/users/{id}</code> elimine un usuario por id. C\u00f3digos de respuesta: 204 / 404</li> </ul>"},{"location":"good-practice/","title":"Tips de Desarrollo","text":"<ul> <li> <p>Spotless: Herramienta de formateo de c\u00f3digo que asegura un estilo coherente en todo el proyecto.</p> </li> <li> <p>Adicionamos dentro del pom.xml en properties esta linea <pre><code>&lt;spotless-maven-plugin.version&gt;2.43.0&lt;/spotless-maven-plugin.version&gt;\n</code></pre></p> </li> <li>En la parte de build -&gt; plugins adicionamos las siguientes lineas.</li> </ul> <p>pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.diffplug.spotless&lt;/groupId&gt;\n    &lt;artifactId&gt;spotless-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;${spotless-maven-plugin.version}&lt;/version&gt;\n    &lt;configuration&gt;\n        &lt;java&gt;\n            &lt;importOrder /&gt;\n            &lt;removeUnusedImports /&gt;\n            &lt;palantirJavaFormat&gt;\n                &lt;version&gt;2.43.0&lt;/version&gt;\n            &lt;/palantirJavaFormat&gt;\n            &lt;formatAnnotations /&gt;\n        &lt;/java&gt;\n    &lt;/configuration&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n        &lt;phase&gt;compile&lt;/phase&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;check&lt;/goal&gt;\n            &lt;/goals&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre> - Ejecutamos este comando para aplicar el formato en todo el proyecto.</p> <pre><code>mvn spotless:apply\n</code></pre> <ul> <li>Taskfile.dev: Herramienta de automatizaci\u00f3n que se emplea para definir y ejecutar tareas de desarrollo, como compilaciones y ejecuci\u00f3n de pruebas.</li> </ul> Taskfile.yml<pre><code>version: '3'\n\nvars:\n  GOOS: \"{{default OS .GOOS}}\"\n  MVN: 'mvn'\n\ntasks:\n  default:\n    cmds:\n      - task: test\n\n  format:\n    cmds:\n      - \"{{.MVN}} spotless:apply\"\n\n  run_app:\n    cmds:\n      - \"{{.MVN}} spring-boot:run\"\n\n  test:\n    deps: [format]\n    cmds:\n      - \"{{.MVN}} clean verify\"\n</code></pre>"},{"location":"integration-paypal/","title":"Integraci\u00f3n con Paypal API","text":""},{"location":"integration-paypal/#introduccion-a-la-integracion-con-paypal-api","title":"Introducci\u00f3n a la Integraci\u00f3n con PayPal API","text":"<p>En esta secci\u00f3n, exploraremos c\u00f3mo integrar la API de PayPal en una aplicaci\u00f3n desarrollada con Spring Boot.</p> <p>PayPal es uno de los proveedores de servicios de pago m\u00e1s populares y confiables a nivel mundial, ofreciendo una soluci\u00f3n segura y f\u00e1cil de usar para procesar pagos en l\u00ednea.</p> <p>El objetivo de esta integraci\u00f3n es proporcionar una experiencia de pago fluida y segura para los usuarios de nuestra aplicaci\u00f3n. A lo largo de esta gu\u00eda, cubriremos los pasos necesarios para configurar y utilizar la API de PayPal, desde la creaci\u00f3n de una orden de pago hasta la captura del pago final.</p>"},{"location":"integration-paypal/#beneficios-de-integrar-paypal-en-tu-aplicacion","title":"Beneficios de Integrar PayPal en tu Aplicaci\u00f3n","text":"<ul> <li>Seguridad: PayPal maneja la seguridad y protecci\u00f3n de los datos de pago del usuario.</li> <li>Confiabilidad: Con millones de usuarios en todo el mundo, PayPal es una plataforma probada y confiable para procesar pagos.</li> <li>Facilidad de Uso: La API de PayPal es f\u00e1cil de integrar y proporciona una experiencia de usuario intuitiva y eficiente.</li> <li>Compatibilidad Global: Permite aceptar pagos de clientes en diferentes pa\u00edses y en m\u00faltiples monedas.</li> </ul>"},{"location":"integration-paypal/#diseno-del-flujo-de-pago","title":"Dise\u00f1o del Flujo de Pago","text":"<p>El diagrama adjunto ilustra el flujo de pago completo utilizando PayPal, destacando las interacciones entre el cliente, el servidor y PayPal. A continuaci\u00f3n, detallamos los pasos clave del proceso:</p> <ul> <li> <p>1. Inicio del Proceso de Pago</p> <ul> <li>Cliente: El usuario inicia el proceso de pago desde el cliente (por ejemplo, un navegador web).</li> <li>Acci\u00f3n: El cliente env\u00eda una solicitud al servidor para iniciar el proceso de pago.</li> </ul> </li> <li> <p>2. Creaci\u00f3n de la Orden de Pago</p> <ul> <li>Servidor: El servidor recibe la solicitud de inicio de pago y procede a crear una orden de pago en PayPal.</li> <li>Acci\u00f3n: El servidor env\u00eda una solicitud a la API de PayPal para crear una orden de pago.</li> <li>Encabezado (Header): H: Bearer Token - La solicitud incluye un token de autorizaci\u00f3n (Bearer Token) que autentica la solicitud en PayPal.</li> </ul> </li> <li>3. Respuesta de Creaci\u00f3n de la Orden<ul> <li>PayPal: PayPal recibe la solicitud de creaci\u00f3n de la orden de pago y procesa la solicitud.</li> <li>Acci\u00f3n: PayPal responde al servidor con los detalles de la orden creada, incluyendo una URL de redirecci\u00f3n para la aprobaci\u00f3n del pago por parte del usuario.</li> </ul> </li> <li>4. URL de Redirecci\u00f3n hacia la P\u00e1gina de Aprobaci\u00f3n de Pago<ul> <li>Servidor: El servidor recibe la respuesta de PayPal y extrae la URL de redirecci\u00f3n para la aprobaci\u00f3n del pago.</li> <li>Acci\u00f3n: El servidor env\u00eda esta URL de redirecci\u00f3n al cliente.</li> </ul> </li> <li>5. Confirmaci\u00f3n del Pago<ul> <li>Cliente: El cliente recibe la URL de redirecci\u00f3n y redirige al usuario a la p\u00e1gina de aprobaci\u00f3n de pago de PayPal.</li> <li>Acci\u00f3n: El usuario revisa y confirma el pago en la p\u00e1gina de PayPal.</li> </ul> </li> <li>6. Redirecci\u00f3n a la P\u00e1gina de \u00c9xito<ul> <li>PayPal: Una vez que el usuario aprueba el pago, PayPal redirige al usuario de vuelta al servidor utilizando una URL de redirecci\u00f3n proporcionada por el servidor.</li> <li>Acci\u00f3n: PayPal incluye un token en la URL de redirecci\u00f3n que permite al servidor identificar y verificar el pago.</li> </ul> </li> <li>7. Comprobaci\u00f3n del Pago<ul> <li>Servidor: El servidor recibe la redirecci\u00f3n desde PayPal con el token incluido en la URL.</li> <li>Acci\u00f3n: El servidor env\u00eda una solicitud a la API de PayPal para comprobar el estado del pago utilizando el token recibido.</li> <li>Par\u00e1metro (Query Parameter): ?Token - El token incluido en la URL permite verificar la transacci\u00f3n.</li> </ul> </li> <li>8. Captura del Pago<ul> <li>Servidor: Si el pago es confirmado, el servidor procede a capturar el pago.</li> <li>Acci\u00f3n: El servidor env\u00eda una solicitud a la API de PayPal para capturar el pago.</li> <li>Encabezado (Header): H: Bearer Token - La solicitud incluye un token de autorizaci\u00f3n (Bearer Token) que autentica la solicitud en PayPal.</li> </ul> </li> <li>9. Respuesta de Captura del Pago<ul> <li>PayPal: PayPal procesa la captura del pago y env\u00eda una respuesta al servidor con los detalles de la transacci\u00f3n capturada.</li> <li>Acci\u00f3n: PayPal confirma al servidor que el pago ha sido capturado exitosamente.</li> </ul> </li> <li>10. Respuesta Final<ul> <li>Servidor: El servidor recibe la respuesta de captura del pago y procesa la informaci\u00f3n.</li> <li>Acci\u00f3n: El servidor responde al cliente, indicando que el pago ha sido completado exitosamente.</li> </ul> </li> </ul>"},{"location":"integration-paypal/#datos-de-las-credenciales-de-paypal-app","title":"Datos de las credenciales de PayPal App","text":"<p>Para integrar PayPal en tu aplicaci\u00f3n, necesitar\u00e1s las credenciales de tu aplicaci\u00f3n PayPal. Estas credenciales son necesarias para autenticar las solicitudes que tu servidor har\u00e1 a la API de PayPal.</p> <ol> <li>Client ID: Este es el identificador p\u00fablico de tu aplicaci\u00f3n. Ejemplo: <code>Aa-dr-NstbDTv_lE7bGEH7eJRJdxo1CHmoiTUM5qX_F8XoXIHTn-26YuMiHTSVld5XwjPs0OUe7o67Z2</code></li> <li>Secret Key: Esta es la clave secreta de tu aplicaci\u00f3n, usada para autenticar tus solicitudes junto con el Client ID. Ejemplo: <code>EGFt988GJmVa4a_2BUEMXPZkygOJgY96dER0p_UxIc5UvCI-tVEnUbH-gSJ1t8NTkq7Rjklj6UbbF6gt</code></li> <li>Sandbox URL: Utiliza esta URL para realizar pruebas con PayPal en el entorno sandbox. URL: <code>https://api-m.sandbox.paypal.com</code></li> </ol>"},{"location":"integration-paypal/#datos-de-la-cuenta-personal-de-pruebas-paypal","title":"Datos de la cuenta personal de pruebas PayPal:","text":"<p>Para realizar pruebas de integraci\u00f3n, puedes utilizar una cuenta de pruebas en el entorno sandbox de PayPal. Aqu\u00ed tienes un ejemplo de los datos de una cuenta de pruebas:</p> <ol> <li>Email: <code>geovanny-test@personal.example.com</code></li> <li>Contrase\u00f1a: <code>ow#)_R8w</code></li> </ol>"},{"location":"integration-paypal/#guia-de-paypal","title":"Gu\u00eda de PayPal","text":"<p>En esta secci\u00f3n, aprender\u00e1s a implementar la creaci\u00f3n de ventas utilizando la API de PayPal. Esto incluye la creaci\u00f3n de \u00f3rdenes de pago, la captura de pagos y la gesti\u00f3n de descargas de archivos comprados.</p>"},{"location":"integration-paypal/#creacion-de-venta","title":"Creaci\u00f3n De Venta","text":"<ol> <li>Crear un servicio llamado <code>SalesOrderService</code> que se encargue de crear una venta a partir de una lista de ID's de libros.</li> <li>Crear los Endpoints en <code>OrderController</code>    Define los endpoints que permitir\u00e1n realizar solicitudes HTTP relacionadas con el proceso de compra y gesti\u00f3n de ventas.<ul> <li>Endpoint 1: Crear Orden de PayPal<ul> <li>Descripci\u00f3n: Crea una orden de paypal y retorna el enlace de pago.</li> <li>HTTP: Method: <code>POST</code></li> <li>URL: <code>/api/checkout/paypal/create</code></li> <li>Body: lista de IDs de libros a comprar</li> <li>Query Param: <code>returnUrl</code> - una URL de retorno en caso suceda un \u00e9xito o error cuando se realice el pago con paypal.</li> <li>Response: <code>{\"approveUrl\": \"el enlace de pago de paypal\"}</code></li> </ul> </li> <li>Endpoint 2: Capturar Pago de PayPal<ul> <li>Descripci\u00f3n: Consulta si el pago se ha realizado correctamente y devuelve su estado.</li> <li>HTTP Method: <code>POST</code></li> <li>URL: <code>/checkout/paypal/capture</code></li> <li>Query Param: <code>token</code> - El token que retorna PayPal e identifica una orden de compra.</li> <li>Response: <code>{\"completed\": \"verdadero si el pago fue completado\", \"orderId\": \"el id de la venta\"}</code></li> </ul> </li> <li>Endpoint 3: Descargar Libro<ul> <li>Descripci\u00f3n: Retorna el archivo PDF de un libro y disminuye el n\u00famero de descargas disponibles.</li> <li>HTTP Method: <code>GET</code></li> <li>URL: <code>/orders/{orderId}/items/{itemId}/book/download</code></li> <li>Variables: orderId - ID de la venta, itemId - ID del \u00edtem de venta.</li> <li>Response: El archivo como un Resource de Spring.</li> </ul> </li> </ul> </li> </ol>"},{"location":"integration-paypal/#1-creacion-del-token-de-acceso","title":"1. Creaci\u00f3n del Token de Acceso","text":"<p>Figura #1</p>"},{"location":"integration-paypal/#1solicitud-de-token-de-acceso","title":"1.Solicitud de Token de Acceso","text":"<ul> <li>Cliente (BookStoreApi) env\u00eda una solicitud POST a la URL /v1/oauth2/token en PayPal.</li> <li>Encabezados (Headers):</li> <li>ContentType: application/x-www-form-urlencoded</li> <li>BasicAuth: ClientId:ClientSecret</li> <li>Cuerpo (Body):<ul> <li>grant_type: client_credentials</li> </ul> </li> <li>Respuesta de PayPal<ul> <li>PayPal responde con un token de acceso.</li> <li>El token de acceso tiene la siguiente estructura en JSON: </li> </ul> </li> </ul> <p>Este token de acceso se utilizar\u00e1 para autenticar todas las solicitudes posteriores a la API de PayPal.</p>"},{"location":"integration-paypal/#2-creacion-de-la-orden-de-pago","title":"2. Creaci\u00f3n de la Orden de Pago","text":"<p>Figura #2</p>"},{"location":"integration-paypal/#1-solicitud-para-crear-una-orden","title":"1. Solicitud para Crear una Orden","text":"<ul> <li>Cliente (BookStoreApi) env\u00eda una solicitud POST a la URL /v2/checkout/orders en PayPal.</li> <li>Encabezados (Headers):<ul> <li>ContentType: application/json</li> <li>Authentication: Bearer Token</li> </ul> </li> <li>Cuerpo (Body): Figura #2 </li> </ul>"},{"location":"integration-paypal/#2-respuesta-de-paypal","title":"2. Respuesta de PayPal","text":"<ul> <li>PayPal responde con los detalles de la orden creada.</li> <li>La respuesta tiene la siguiente estructura en JSON: </li> </ul> <p>El enlace con rel: \"approve\" es el que el cliente debe seguir para aprobar la orden de pago.</p> <ol> <li>Captura de la Orden de Pago </li> </ol> <p>Figura #3</p>"},{"location":"integration-paypal/#1solicitud-para-capturar-la-orden","title":"1.Solicitud para Capturar la Orden","text":"<ul> <li>Cliente (BookStoreApi) env\u00eda una solicitud <code>POST</code> a la URL <code>/v2/checkout/orders/{orderId}/capture</code> en PayPal, donde <code>{orderId}</code> es el ID de la orden creada en el paso anterior.</li> <li>Encabezados (Headers):<ul> <li><code>ContentType</code>: <code>application/json</code></li> <li><code>Authentication</code>: <code>Bearer Token</code></li> </ul> </li> </ul>"},{"location":"integration-paypal/#2-respuesta-de-paypal_1","title":"2. Respuesta de PayPal","text":"<ul> <li>PayPal responde con los detalles de la orden capturada.</li> <li>La respuesta tiene la siguiente estructura en JSON: </li> </ul> <p>En Resumen</p> <ol> <li>Creaci\u00f3n del Token de Acceso: Autenticar las solicitudes a la API de PayPal obteniendo un token de acceso.</li> <li>Creaci\u00f3n de la Orden de Pago: Crear una orden de pago en PayPal y obtener el enlace para que el cliente apruebe el pago.</li> <li>Captura de la Orden de Pago: Capturar la orden de pago aprobada y confirmar la transacci\u00f3n.</li> </ol>"},{"location":"integration-paypal/#detalle-de-la-integracion-con-paypal","title":"Detalle de la Integraci\u00f3n con PayPal","text":"<p>En esta secci\u00f3n, explicaremos c\u00f3mo integrar PayPal en una aplicaci\u00f3n Spring Boot, detallando la creaci\u00f3n de DTOs, el servicio de PayPal, y los controladores necesarios para manejar el flujo de pago. La conclusi\u00f3n resumir\u00e1 todo lo que hemos hecho.</p>"},{"location":"integration-paypal/#1-crear-los-dtos-para-paypal","title":"1. Crear los DTOs para PayPal","text":"<p>Los DTOs (Data Transfer Objects) son necesarios para estructurar los datos que enviaremos y recibiremos desde la API de PayPal.</p> <p>TokenResponse</p> TokenResponse.java<pre><code>public record TokenResponse(\n    @JsonProperty(\"access_token\") String accessToken,\n    @JsonProperty(\"token_type\") String tokenType,\n    @JsonProperty(\"app_id\") String appId,\n    @JsonProperty(\"expires_in\") Long expiresIn\n) {}\n</code></pre> <ul> <li>TokenResponse: Estructura de datos para manejar la respuesta del token de acceso de PayPal.</li> </ul> <p>ApplicationContext</p> ApplicationContext.java<pre><code>public record ApplicationContext(\n        @JsonProperty(\"brand_name\") String brandName,\n        @JsonProperty(\"return_url\") String returnUrl,\n        @JsonProperty(\"cancel_url\") String cancelUrl\n) { }\n</code></pre> <ul> <li>ApplicationContext: Estructura de datos para manejar el contexto de la aplicaci\u00f3n en PayPal.</li> </ul> <p>Amount y CurrencyCode</p> Amount.java &amp; CurrencyCode.java<pre><code>public record Amount(\n        @JsonProperty(\"currency_code\")\n        CurrencyCode currencyCode,\n        String value,\n        Breakdown breakdown\n) { }\n\npublic enum CurrencyCode {\n    USD\n}\n</code></pre> <ul> <li>Amount: Estructura de datos para manejar el monto y la moneda de la transacci\u00f3n.</li> <li>CurrencyCode: Enum para manejar los c\u00f3digos de moneda.</li> </ul> <p>Breakdown</p> Breakdown.java<pre><code>@Getter\n@Setter\n@NoArgsConstructor\n@Builder\n@RequiredArgsConstructor\npublic class Breakdown {\n    @NonNull\n    @JsonProperty(\"item_total\")\n    private Amount itemTotal;\n}\n</code></pre> <ul> <li>Breakdown: Estructura de datos para manejar el desglose del monto de la transacci\u00f3n.</li> </ul> <p>OrderItem</p> OrderItem.java<pre><code>public record OrderItem(\n        String name,\n        String sku,\n        String quantity,\n        @JsonProperty(\"unit_amount\") Amount unitAmount\n) { }\n</code></pre> <ul> <li>OrderItem: Estructura de datos para manejar los \u00edtems de la orden.</li> </ul> <p>PurchaseUnit</p> PurchaseUnit.java<pre><code>public record PurchaseUnit(\n        @JsonProperty(\"reference_id\")\n        String referenceId,\n        Amount amount,\n        List&lt;OrderItem&gt; items\n) {\n}\n</code></pre> <ul> <li>PurchaseUnit: Estructura de datos para manejar las unidades de compra.</li> </ul> <p>OrderRequest, Intent y OrderResponse</p> OrderRequest.java, OrderResponse.java &amp; Intent.java<pre><code>public record OrderRequest(\n        @JsonProperty(\"application_context\")\n        ApplicationContext applicationContext,\n        Intent intent,\n        @JsonProperty(\"purchase_units\")\n        List&lt;PurchaseUnit&gt; purchaseUnits\n) {}\n\npublic record OrderResponse(\n        String id,\n        String status,\n        List&lt;Link&gt; links\n) {}\n\npublic enum Intent {\n    CAPTURE\n}\n</code></pre> <ul> <li>OrderRequest: Estructura de datos para enviar la solicitud de creaci\u00f3n de una orden.</li> <li>OrderResponse: Estructura de datos para manejar la respuesta de la creaci\u00f3n de una orden.</li> <li>Intent: Define el prop\u00f3sito o la intenci\u00f3n de una operaci\u00f3n espec\u00edfica en nuestro sistema. En este caso, la \u00fanica intenci\u00f3n disponible es <code>CAPTURE</code>.<ul> <li><code>CAPTURE</code>: Este valor indica que la operaci\u00f3n tiene la intenci\u00f3n de capturar una transacci\u00f3n, como un pago o una autorizaci\u00f3n en un sistema de procesamiento de pagos.</li> </ul> </li> </ul> <p>Link y OrderCaptureResponse</p> Link.java &amp; OrderCaptureResponse.java<pre><code>public record Link(\n        String href,\n        String rel,\n        String method\n) {}\n\npublic record OrderCaptureResponse(\n        String id,\n        String status,\n        @JsonProperty(\"purchase_units\")\n        List&lt;PurchaseUnit&gt; purchaseUnits\n) { }\n</code></pre> <ul> <li>Link: Estructura de datos para manejar los enlaces proporcionados por PayPal.</li> <li>OrderCaptureResponse: Estructura de datos para manejar la respuesta de captura de una orden.</li> </ul>"},{"location":"integration-paypal/#2-configuracion-en-applicationproperties","title":"2. Configuraci\u00f3n en <code>application.properties</code>","text":"application.properties<pre><code>######## Paypal Configuration  #########\npaypal.api.base=https://api-m.sandbox.paypal.com\npaypal.client.id=Aa-dr-NstbDTv_lE7bGEH7eJRJdxo1CHmoiTUM5qX_F8XoXIHTn-26YuMiHTSVld5XwjPs0OUe7o67Z2\npaypal.client.secret=EGFt988GJmVa4a_2BUEMXPZkygOJgY96dER0p_UxIc5UvCI-tVEnUbH-gSJ1t8NTkq7Rjklj6UbbF6gt\n</code></pre> <ul> <li>paypal.api.base: URL base de la API de PayPal.</li> <li>paypal.client.id: ID del cliente de PayPal.</li> <li>paypal.client.secret: Secreto del cliente de PayPal.</li> </ul>"},{"location":"integration-paypal/#3-crear-un-servicio-llamado-paypalservice-con-los-siguientes-atributos","title":"3. Crear un servicio llamado PaypalService con los siguientes atributos.","text":"<ul> <li>Atributos del Servicio</li> </ul> <pre><code>    @Value(\"${paypal.api.base}\")\n    private  String paypalApiBase;\n    @Value(\"${paypal.client.id}\")\n    private String paypalClientId;\n    @Value(\"${paypal.client.secret}\")\n    private String paypalClientSecret;\n</code></pre> <p>Utilizamos la anotaci\u00f3n <code>@Value</code> para inyectar las propiedades de configuraci\u00f3n desde <code>application.properties</code>, incluyendo la URL base de la API de PayPal, el ID del cliente y el secreto del cliente.</p>"},{"location":"integration-paypal/#4-crear-un-metodo-en-el-servicio-que-obtenga-el-access-token-de-paypal","title":"4. Crear un m\u00e9todo en el servicio que obtenga el access token de paypal.","text":"<p>Este m\u00e9todo <code>getAccessToken</code> construye la URL para obtener el token de acceso utilizando la URL base de la API de PayPal. Configura los encabezados HTTP para que el contenido sea <code>application/x-www-form-urlencoded</code> y a\u00f1ade autenticaci\u00f3n b\u00e1sica con el ID y el secreto del cliente. Luego, construye un formulario HTTP con el tipo de concesi\u00f3n <code>client_credentials</code>. Finalmente, realiza una solicitud POST a PayPal y devuelve el token de acceso de la respuesta.</p> PaypalService.java<pre><code>   public String getAccessToken() {\n        String url = String.format(\"%s/v1/oauth2/token\",paypalApiBase);\n        RestTemplate restTemplate = new RestTemplate();\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\n        headers.setBasicAuth(paypalClientId, paypalClientSecret);\n\n        // FormHttpMessageConverter is configured by default\n        MultiValueMap&lt;String, String&gt; form = new LinkedMultiValueMap&lt;&gt;();\n        form.add(\"grant_type\", \"client_credentials\");\n\n        HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(form, headers);\n        ResponseEntity&lt;TokenResponse&gt; response = restTemplate.postForEntity(url, entity, TokenResponse.class);\n\n        return response.getBody().accessToken();\n    }\n</code></pre> <ul> <li> <p>L\u00ednea 2:</p> <ul> <li> <p>Construcci\u00f3n de la URL:</p> <pre><code>String url = String.format(\"%s/v1/oauth2/token\", paypalApiBase);\n</code></pre> </li> <li> <p>Se construye la URL para la solicitud de token de acceso usando la URL base de la API de PayPal (<code>paypalApiBase</code>).</p> </li> </ul> </li> <li> <p>L\u00ednea 3:</p> <ul> <li> <p>Creaci\u00f3n de RestTemplate:</p> <pre><code>RestTemplate restTemplate = new RestTemplate();\n</code></pre> </li> <li> <p>Se crea una instancia de <code>RestTemplate</code> para realizar la solicitud HTTP.</p> </li> </ul> </li> <li> <p>L\u00ednea 4-7:</p> <ul> <li> <p>Configuraci\u00f3n de los Encabezados HTTP:</p> <pre><code>HttpHeaders headers = new HttpHeaders();\nheaders.setContentType(MediaType.APPLICATION_FORM_URLENCODED);\nheaders.setBasicAuth(paypalClientId, paypalClientSecret);\n</code></pre> </li> <li> <p>Se configuran los encabezados HTTP:</p> <ul> <li><code>Content-Type</code> se establece como <code>application/x-www-form-urlencoded</code></li> <li><code>BasicAuth</code> se configura con el ID y el secreto del cliente PayPal para la autenticaci\u00f3n b\u00e1sica.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 10-11:</p> <ul> <li> <p>Creaci\u00f3n del Cuerpo de la Solicitud:</p> <pre><code>MultiValueMap&lt;String, String&gt; form = new LinkedMultiValueMap&lt;&gt;();\nform.add(\"grant_type\", \"client_credentials\");\n</code></pre> </li> <li> <p>Se crea un <code>MultiValueMap</code> para el cuerpo de la solicitud.</p> </li> <li><code>MultiValueMap</code> es una implementaci\u00f3n de mapa que permite almacenar m\u00faltiples valores para una sola clave, \u00fatil cuando se necesita enviar datos en formato <code>application/x-www-form-urlencoded</code>.</li> <li>En este caso, solo se a\u00f1ade un par\u00e1metro <code>grant_type</code> con el valor <code>client_credentials</code>. Esto indica que estamos solicitando un token de acceso utilizando las credenciales del cliente.</li> </ul> </li> <li> <p>L\u00ednea 13:</p> <ul> <li> <p>Creaci\u00f3n de la Entidad HTTP:</p> <pre><code>HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt; entity = new HttpEntity&lt;&gt;(form, headers);\n</code></pre> <ul> <li>Se crea una instancia de <code>HttpEntity</code> que combina los encabezados y el cuerpo de la solicitud. <code>HttpEntity</code> es una clase de Spring que representa la entidad HTTP, la cual incluye los datos del formulario y los encabezados HTTP configurados anteriormente.</li> <li><code>HttpEntity&lt;MultiValueMap&lt;String, String&gt;&gt;</code> indica que la entidad contiene un cuerpo de tipo <code>MultiValueMap</code>, el cual es adecuado para enviar datos en formato <code>application/x-www-form-urlencoded</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 14:</p> <ul> <li> <p>Realizaci\u00f3n de la Solicitud POST:</p> <pre><code>ResponseEntity&lt;TokenResponse&gt; response = restTemplate.postForEntity(url, entity, TokenResponse.class);\n</code></pre> <ul> <li>Se realiza una solicitud POST a PayPal utilizando <code>RestTemplate</code>, enviando la entidad HTTP y esperando una respuesta de tipo <code>TokenResponse</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 16:</p> <ul> <li> <p>Obtenci\u00f3n y Retorno del Token de Acceso:</p> <pre><code>return response.getBody().accessToken();\n</code></pre> <ul> <li>Se extrae y retorna el token de acceso desde el cuerpo de la respuesta.</li> </ul> </li> </ul> </li> </ul> <p>Este m\u00e9todo <code>getAccessToken</code> permite obtener un token de acceso de PayPal, necesario para autenticar las solicitudes subsecuentes a la API de PayPal.</p>"},{"location":"integration-paypal/#5-crear-un-metodo-para-crear-la-orden-de-compra-en-paypal","title":"5. Crear un m\u00e9todo para crear la orden de compra en paypal.","text":"<p>El m\u00e9todo <code>createOrder</code> crea una orden en PayPal. Primero, construye la URL para la creaci\u00f3n de la orden y configura el contexto de la aplicaci\u00f3n con las URLs de retorno y cancelaci\u00f3n. Luego, construye una lista de \u00edtems de la orden a partir de los \u00edtems de la orden de venta (<code>salesOrder</code>). Calcula el monto total de los \u00edtems y crea la unidad de compra (<code>PurchaseUnit</code>). Construye la solicitud de orden (<code>OrderRequest</code>) y obtiene un token de acceso. Configura los encabezados HTTP con el token de acceso y realiza una solicitud POST a PayPal para crear la orden, devolviendo la respuesta de la orden.</p> PaypalService.java<pre><code>    public OrderResponse createOrder(SalesOrderEntity salesOrder, String returnUrl, String cancelUrl) {\n        String url = String.format(\"%s/v2/checkout/orders\", paypalApiBase);\n\n        ApplicationContext applicationContext = new ApplicationContext(\"JCONF DOMINICANA\", returnUrl, cancelUrl);\n\n        List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();\n        salesOrder.getItems().forEach(salesItem -&gt; {\n            BookEntity book = salesItem.getBookEntity();\n            Amount unitAmount = new Amount(CurrencyCode.USD, salesItem.getPrice().toString(), null);\n            orderItems.add(new OrderItem(book.getName(), book.getId().toString(), \"1\", unitAmount));\n        });\n\n        Amount itemsAmount = new Amount(CurrencyCode.USD, salesOrder.getTotal().toString(), null);\n        Amount purchaseAmount = new Amount(CurrencyCode.USD, salesOrder.getTotal().toString(), new Breakdown(itemsAmount));\n\n        PurchaseUnit purchaseUnit = new PurchaseUnit(salesOrder.getId().toString(), purchaseAmount, orderItems);\n\n        OrderRequest orderRequest = new OrderRequest(applicationContext, Intent.CAPTURE, Collections.singletonList(purchaseUnit));\n\n        // get access token\n        String accessToken = getAccessToken();\n\n        // create http request\n        HttpHeaders headers = new HttpHeaders();\n        headers.setBearerAuth(accessToken);\n\n        HttpEntity&lt;OrderRequest&gt; entity = new HttpEntity&lt;&gt;(orderRequest, headers);\n        RestTemplate restTemplate = new RestTemplate();\n        ResponseEntity&lt;OrderResponse&gt; response = restTemplate.postForEntity(url, entity, OrderResponse.class);\n\n        return response.getBody();\n    }\n</code></pre> <ul> <li> <p>L\u00ednea 2:</p> <ul> <li> <p>Construcci\u00f3n de la URL::</p> <pre><code>String url = String.format(\"%s/v2/checkout/orders\", paypalApiBase);\n</code></pre> <ul> <li>Se construye la URL para crear una orden utilizando la URL base de la API de PayPal (<code>paypalApiBase</code>) y concatenando la ruta <code>/v2/checkout/orders</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 4:</p> <ul> <li> <p>Configuraci\u00f3n del Contexto de la Aplicaci\u00f3n:</p> <pre><code>ApplicationContext applicationContext = new ApplicationContext(\"JCONF DOMINICANA\", returnUrl, cancelUrl);\n</code></pre> <ul> <li>Se crea un <code>ApplicationContext</code> con el nombre de la marca, la URL de retorno y la URL de cancelaci\u00f3n. Este contexto se utiliza para configurar la experiencia del usuario en PayPal.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 6-11:</p> <ul> <li> <p>Creaci\u00f3n de la Lista de \u00cdtems de la Orden:</p> <pre><code>List&lt;OrderItem&gt; orderItems = new ArrayList&lt;&gt;();\nsalesOrder.getItems().forEach(salesItem -&gt; {\n    BookEntity book = salesItem.getBookEntity();\n    Amount unitAmount = new Amount(CurrencyCode.USD, salesItem.getPrice().toString(), null);\n    orderItems.add(new OrderItem(book.getName(), book.getId().toString(), \"1\", unitAmount));\n});\n</code></pre> <ul> <li>Se inicializa una lista vac\u00eda de <code>OrderItem</code>.</li> <li>Para cada \u00edtem en la orden de venta (<code>salesOrder</code>):<ul> <li>Se obtiene la entidad del libro asociado.</li> <li>Se crea un objeto <code>Amount</code> para representar el precio del \u00edtem en d\u00f3lares estadounidenses.</li> <li>Se crea un objeto <code>OrderItem</code> con el nombre del libro, el ID, la cantidad y el precio unitario, y se agrega a la lista de \u00edtems.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 13:</p> <ul> <li> <p>Creaci\u00f3n del Monto Total de los \u00cdtems:</p> <pre><code>Amount itemsAmount = new Amount(CurrencyCode.USD, salesOrder.getTotal().toString(), null);\n</code></pre> <ul> <li>Se crea un objeto Amount para representar el monto total de los \u00edtems en d\u00f3lares estadounidenses.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 14:</p> <ul> <li> <p>Creaci\u00f3n del Monto Total de la Compra con Desglose:</p> <pre><code>Amount purchaseAmount = new Amount(CurrencyCode.USD, salesOrder.getTotal().toString(), new Breakdown(itemsAmount));\n</code></pre> <ul> <li>Se crea un objeto Amount para representar el monto total de la compra, incluyendo un desglose que muestra el total de los \u00edtems.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 16:</p> <ul> <li> <p>Creaci\u00f3n de la Unidad de Compra:</p> <pre><code>PurchaseUnit purchaseUnit = new PurchaseUnit(salesOrder.getId().toString(), purchaseAmount, orderItems);\n</code></pre> <ul> <li>Se crea un <code>PurchaseUnit</code> con el <code>ID</code> de la orden de venta, el monto total de la compra y la lista de \u00edtems.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 18:</p> <ul> <li> <p>Creaci\u00f3n de la Solicitud de Orden:</p> <pre><code>OrderRequest orderRequest = new OrderRequest(applicationContext, Intent.CAPTURE, Collections.singletonList(purchaseUnit));\n</code></pre> <ul> <li>Se crea un <code>OrderRequest</code> con el contexto de la aplicaci\u00f3n, la intenci\u00f3n de captura de pagos y una lista que contiene la unidad de compra.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 21:</p> <ul> <li> <p>Obtenci\u00f3n del Token de Acceso:</p> <pre><code>String accessToken = getAccessToken();\n</code></pre> <ul> <li>Se obtiene el token de acceso utilizando el m\u00e9todo <code>getAccessToken</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 24-25:</p> <ul> <li> <p>Configuraci\u00f3n de los Encabezados HTTP:</p> <pre><code>HttpHeaders headers = new HttpHeaders();\nheaders.setBearerAuth(accessToken);\n</code></pre> </li> <li> <p>Se configuran los encabezados <code>HTTP</code>, estableciendo la autenticaci\u00f3n <code>Bearer</code> con el token de acceso.</p> </li> </ul> </li> <li> <p>L\u00ednea 27:</p> <ul> <li> <p>Creaci\u00f3n de la Entidad HTTP:</p> <pre><code>HttpEntity&lt;OrderRequest&gt; entity = new HttpEntity&lt;&gt;(orderRequest, headers);\n</code></pre> <ul> <li>Se crea una entidad HTTP (<code>HttpEntity</code>) que combina la solicitud de orden y los encabezados <code>HTTP</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 28-29:</p> <ul> <li> <p>Realizaci\u00f3n de la Solicitud POST:</p> <pre><code>RestTemplate restTemplate = new RestTemplate();\nResponseEntity&lt;OrderResponse&gt; response = restTemplate.postForEntity(url, entity, OrderResponse.class);\n</code></pre> <ul> <li>Se crea una instancia de <code>RestTemplate</code> para realizar la solicitud HTTP.</li> <li>Se realiza una solicitud POST a PayPal, enviando la entidad HTTP y esperando una respuesta de tipo <code>OrderResponse</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 31:</p> <ul> <li> <p>Devoluci\u00f3n de la Respuesta de la Orden:</p> <pre><code>return response.getBody();\n</code></pre> <ul> <li>Se extrae y devuelve el cuerpo de la respuesta de la orden.</li> </ul> </li> </ul> </li> </ul> <p>Este m\u00e9todo <code>createOrder</code> permite crear una orden de pago en PayPal, configurando todos los detalles necesarios y realizando la solicitud correspondiente a la API de PayPal.</p>"},{"location":"integration-paypal/#6-crear-un-metodo-para-capturar-la-orden-de-compra-consultar-el-estado-de-pago-de-paypal","title":"6. Crear un m\u00e9todo para capturar la orden de compra (consultar el estado de pago) de paypal.","text":"<p>El m\u00e9todo <code>captureOrder</code> captura una orden en PayPal. Primero, construye la URL para capturar la orden y obtiene un token de acceso. Configura los encabezados HTTP con el token de acceso y establece el tipo de contenido como JSON. Realiza una solicitud POST a PayPal para capturar la orden y devuelve la respuesta de la captura de la orden. Si hay un error en la solicitud HTTP, maneja la excepci\u00f3n y devuelve <code>null</code>.</p> PaypalService.java<pre><code>public OrderCaptureResponse captureOrder(String orderId) {\n        String url = String.format(\"%s/v2/checkout/orders/%s/capture\", paypalApiBase, orderId);\n\n        // get access token\n        String accessToken = getAccessToken();\n\n        // create http request\n        HttpHeaders headers = new HttpHeaders();\n        headers.setBearerAuth(accessToken);\n        headers.setContentType(MediaType.APPLICATION_JSON);\n\n        try {\n            HttpEntity&lt;Object&gt; entity = new HttpEntity&lt;&gt;(null, headers);\n            RestTemplate restTemplate = new RestTemplate();\n            ResponseEntity&lt;OrderCaptureResponse&gt; response = restTemplate.postForEntity(url, entity, OrderCaptureResponse.class);\n\n            return response.getBody();\n        } catch (HttpClientErrorException e) {\n            return null;\n        }\n    }\n</code></pre> <ul> <li> <p>L\u00ednea 2:</p> <ul> <li> <p>Construcci\u00f3n de la URL:</p> <pre><code>String url = String.format(\"%s/v2/checkout/orders/%s/capture\", paypalApiBase, orderId);\n</code></pre> <ul> <li>Se construye la URL para capturar una orden utilizando la URL base de la API de PayPal (<code>paypalApiBase</code>) y el ID de la orden (<code>orderId</code>). La URL resultante tendr\u00e1 el formato <code>https://api.paypal.com/v2/checkout/orders/{orderId}/capture</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 5:</p> <ul> <li> <p>Obtenci\u00f3n del Token de Acceso:</p> <pre><code>String accessToken = getAccessToken();\n</code></pre> <ul> <li>Se obtiene el token de acceso utilizando el m\u00e9todo <code>getAccessToken</code>. Este token es necesario para autenticar la solicitud a la API de PayPal.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 8-10:</p> <ul> <li> <p>Configuraci\u00f3n de los Encabezados HTTP:</p> <pre><code>HttpHeaders headers = new HttpHeaders();\nheaders.setBearerAuth(accessToken);\nheaders.setContentType(MediaType.APPLICATION_JSON);\n</code></pre> </li> <li> <p>Se configuran los encabezados HTTP:**</p> <ul> <li><code>BearerAuth</code> se configura con el token de acceso obtenido anteriormente.</li> <li><code>Content-Type</code> se establece como application/json, ya que la API de PayPal espera recibir y devolver datos en formato JSON.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 13:</p> <ul> <li> <p>Creaci\u00f3n de la Entidad HTTP:</p> <pre><code>HttpEntity&lt;Object&gt; entity = new HttpEntity&lt;&gt;(null, headers);\n</code></pre> <ul> <li>Se crea una instancia de <code>HttpEntity</code> que combina los encabezados HTTP configurados. El cuerpo de la solicitud es <code>null</code> ya que no se requiere enviar datos adicionales en el cuerpo de la solicitud de captura.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 14-15:</p> <ul> <li>Realizaci\u00f3n de la Solicitud POST:</li> </ul> <pre><code>RestTemplate restTemplate = new RestTemplate();\nResponseEntity&lt;OrderCaptureResponse&gt; response = restTemplate.postForEntity(url, entity, OrderCaptureResponse.class);\n</code></pre> <ul> <li>Se crea una instancia de <code>RestTemplate</code> para realizar la solicitud HTTP.</li> <li>Se realiza una solicitud POST a la URL de captura de la orden en PayPal, enviando la entidad HTTP. Se espera una respuesta de tipo <code>OrderCaptureResponse</code>.</li> </ul> </li> <li> <p>L\u00ednea 17-19:</p> <ul> <li> <p>Manejo de la Respuesta y Excepciones:</p> <pre><code>return response.getBody();\n} catch (HttpClientErrorException e) {\n    return null;\n}\n</code></pre> <ul> <li>Si la solicitud POST es exitosa, se devuelve el cuerpo de la respuesta (<code>response.getBody()</code>), que contiene los detalles de la captura de la orden.</li> <li>Si ocurre una excepci\u00f3n de tipo <code>HttpClientErrorException</code> durante la solicitud, se captura la excepci\u00f3n y se retorna <code>null</code>. Este manejo b\u00e1sico de excepciones indica que la captura de la orden fall\u00f3.</li> </ul> </li> </ul> </li> </ul> <p>Este m\u00e9todo <code>captureOrder</code> permite capturar una orden de pago en PayPal, realizando la solicitud correspondiente a la API de PayPal y manejando la respuesta o posibles errores de manera adecuada.</p>"},{"location":"integration-paypal/#7-implementacion-del-controlador","title":"7. Implementaci\u00f3n del Controlador","text":"<p>El controlador <code>CheckoutController</code> maneja las solicitudes HTTP relacionadas con el proceso de pago de PayPal. Aqu\u00ed se implementan dos endpoints: uno para crear la orden y otro para capturarla.</p>"},{"location":"integration-paypal/#endpoint-de-crear-order","title":"Endpoint de crear order","text":"<p>El m\u00e9todo <code>createPaypalCheckout</code> crea una orden de venta utilizando el servicio <code>SalesOrderService</code> y luego crea una orden en PayPal utilizando el servicio <code>PaypalService</code>. La URL de aprobaci\u00f3n devuelta por PayPal se extrae de la respuesta y se devuelve en un mapa.</p> CheckoutController.java<pre><code>@PostMapping(\"/paypal/create\")\npublic Map&lt;String, String&gt; createPaypalCheckout(@RequestParam String returnUrl, @RequestBody CreateOrderRequest createOrderRequest) {\n    SalesOrderEntity salesOrder = salesOrderService.createOrder(createOrderRequest.customerId(), createOrderRequest.bookIds());\n    OrderResponse orderResponse = paypalService.createOrder(salesOrder, returnUrl, returnUrl);\n\n    String approveUrl = orderResponse\n            .links()\n            .stream()\n            .filter(link -&gt; link.rel().equals(\"approve\"))\n            .findFirst()\n            .orElseThrow(RuntimeException::new)\n            .href();\n\n    return Map.of(\"approveUrl\", approveUrl);\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1-2:</p> <ul> <li> <p>Definici\u00f3n del M\u00e9todo createPaypalCheckout:</p> <pre><code>@PostMapping(\"/paypal/create\")\npublic Map&lt;String, String&gt; createPaypalCheckout(@RequestParam String returnUrl, @RequestBody CreateOrderRequest createOrderRequest) {\n</code></pre> <ul> <li><code>@PostMapping(\"/paypal/create\")</code>: Define el endpoint que maneja las solicitudes POST a <code>/paypal/create</code>.</li> <li><code>@RequestParam String returnUrl</code>: Captura el par\u00e1metro de consulta <code>returnUrl</code> de la solicitud.</li> <li><code>@RequestBody CreateOrderRequest createOrderRequest</code>: Captura el cuerpo de la solicitud como un objeto CreateOrderRequest.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 3:</p> <ul> <li> <p>Creaci\u00f3n de la Orden de Venta:</p> <pre><code>SalesOrderEntity salesOrder = salesOrderService.createOrder(createOrderRequest.customerId(), createOrderRequest.bookIds());\n</code></pre> <ul> <li>Se crea una orden de venta utilizando el servicio <code>SalesOrderService</code> con el ID del cliente y la lista de IDs de libros.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 4:</p> <ul> <li> <p>Creaci\u00f3n de la Orden en PayPal:</p> <pre><code>OrderResponse orderResponse = paypalService.createOrder(salesOrder, returnUrl, returnUrl);\n</code></pre> <ul> <li>Se crea una orden en PayPal utilizando el servicio <code>PaypalService</code>, pasando la orden de venta y las URLs de retorno y cancelaci\u00f3n.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 6-12:</p> <ul> <li> <p>Extracci\u00f3n de la URL de Aprobaci\u00f3n:</p> <pre><code>String approveUrl = orderResponse\n        .links()\n        .stream()\n        .filter(link -&gt; link.rel().equals(\"approve\"))\n        .findFirst()\n        .orElseThrow(RuntimeException::new)\n        .href();\n</code></pre> <ul> <li>Se extrae la URL de aprobaci\u00f3n de la respuesta de PayPal, filtrando los enlaces y buscando el que tiene la relaci\u00f3n (<code>rel</code>) \"approve\".</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 14:</p> <ul> <li> <p>Devoluci\u00f3n de la URL de Aprobaci\u00f3n:</p> <pre><code>return Map.of(\"approveUrl\", approveUrl);\n</code></pre> <ul> <li>Se devuelve la URL de aprobaci\u00f3n en un mapa.</li> </ul> </li> </ul> </li> </ul>"},{"location":"integration-paypal/#clase-createorderrequest","title":"Clase CreateOrderRequest","text":"<p>La clase CreateOrderRequest es una representaci\u00f3n de un objeto de transferencia de datos (DTO) utilizado para crear una nueva orden en el sistema. Esta clase encapsula la informaci\u00f3n necesaria para realizar la solicitud de creaci\u00f3n de una orden, incluyendo el ID del cliente y una lista de IDs de libros.</p>"},{"location":"integration-paypal/#propiedades-de-createorderrequest","title":"Propiedades de CreateOrderRequest","text":"<ul> <li>customerId: Identificador \u00fanico del cliente que realiza la orden. Este ID se utiliza para asociar la orden con un cliente espec\u00edfico en el sistema.</li> <li>bookIds: Lista de identificadores \u00fanicos de los libros que se incluyen en la orden. Esta lista contiene los IDs de los libros que el cliente desea comprar.</li> </ul> <pre><code>public record CreateOrderRequest(Long customerId, List&lt;Long&gt; bookIds) {}\n</code></pre> <p>La clase <code>CreateOrderRequest</code> es importante porque:</p> <ul> <li>Facilita la Transferencia de Datos: Proporciona una estructura clara y concisa para transferir la informaci\u00f3n necesaria al crear una nueva orden en el sistema.</li> <li>Asegura la Integridad de los Datos: Al encapsular los datos requeridos para la creaci\u00f3n de una orden, se asegura de que toda la informaci\u00f3n necesaria est\u00e9 presente y correctamente estructurada.</li> <li>Mejora la Legibilidad del C\u00f3digo: Al utilizar un objeto de transferencia de datos (DTO), se mejora la legibilidad y mantenibilidad del c\u00f3digo, ya que se define claramente qu\u00e9 datos son necesarios para la operaci\u00f3n.</li> </ul>"},{"location":"integration-paypal/#endpoint-de-capture-order","title":"Endpoint de Capture order","text":"<p>El m\u00e9todo <code>capturePaypalCheckout</code> captura una orden de PayPal utilizando el servicio <code>PaypalService</code>. Verifica si la captura fue completada y, de ser as\u00ed, actualiza el estado del pago en la base de datos utilizando el servicio <code>SalesOrderService</code>. Devuelve el estado de la captura y el ID de la orden en un mapa.</p> CheckoutController.java<pre><code>@PostMapping(\"/paypal/capture\")\npublic Map&lt;String, Object&gt; capturePaypalCheckout(@RequestParam String token) {\n    OrderCaptureResponse orderCaptureResponse = paypalService.captureOrder(token);\n\n    boolean completed = orderCaptureResponse != null &amp;&amp; orderCaptureResponse.status().equals(\"COMPLETED\");\n    long orderId = 0;\n\n    if (completed) {\n        orderId = Long.parseLong(orderCaptureResponse.purchaseUnits().get(0).referenceId());\n        salesOrderService.updatePaymentStatus(orderId, PaymentStatus.PAID);\n    }\n    return Map.of(\"completed\", completed, \"orderId\", orderId);\n}\n</code></pre> <ul> <li> <p>L\u00ednea 1-2:</p> <ul> <li> <p>Definici\u00f3n del M\u00e9todo capturePaypalCheckout:</p> <pre><code>@PostMapping(\"/paypal/capture\")\npublic Map&lt;String, Object&gt; capturePaypalCheckout(@RequestParam String token) {\n</code></pre> <ul> <li><code>@PostMapping(\"/paypal/capture\")</code>: Define el endpoint que maneja las solicitudes POST a <code>/paypal/capture</code>.</li> <li><code>@RequestParam String token</code>: Captura el par\u00e1metro de consulta token de la solicitud.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 3:</p> <ul> <li> <p>Captura de la Orden en PayPal:</p> <pre><code>OrderCaptureResponse orderCaptureResponse = paypalService.captureOrder(token);\n</code></pre> <ul> <li>Se captura la orden en PayPal utilizando el servicio <code>PaypalService</code> con el token de la orden.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 5-6:</p> <ul> <li> <p>Verificaci\u00f3n de la Captura:</p> <pre><code>boolean completed = orderCaptureResponse != null &amp;&amp; orderCaptureResponse.status().equals(\"COMPLETED\");\nlong orderId = 0;\n</code></pre> <ul> <li>Se verifica si la captura fue completada comprobando que la respuesta no sea <code>null</code> y que el estado de la orden sea \"COMPLETED\".</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 8-11:</p> <ul> <li> <p>Actualizaci\u00f3n del Estado del Pago:</p> <pre><code>if (completed) {\n    orderId = Long.parseLong(orderCaptureResponse.purchaseUnits().get(0).referenceId());\n    salesOrderService.updatePaymentStatus(orderId, PaymentStatus.PAID);\n}\n</code></pre> <ul> <li>Si la captura fue completada, se obtiene el ID de la orden y se actualiza el estado del pago en la base de datos utilizando el servicio <code>SalesOrderService</code>.</li> </ul> </li> </ul> </li> <li> <p>L\u00ednea 12:</p> <ul> <li> <p>Devoluci\u00f3n del Estado de la Captura y el ID de la Orden:</p> <pre><code>return Map.of(\"completed\", completed, \"orderId\", orderId);\n</code></pre> <ul> <li>Se devuelve el estado de la captura y el ID de la orden en un mapa.</li> </ul> </li> </ul> </li> </ul> <p>Este controlador <code>CheckoutController</code> permite manejar el flujo de creaci\u00f3n y captura de \u00f3rdenes de PayPal, integrando servicios para gestionar las \u00f3rdenes y actualizando el estado de los pagos en la base de datos.</p>"},{"location":"integration-paypal/#conclusion","title":"Conclusi\u00f3n","text":"<p>En esta sesi\u00f3n, hemos detallado el proceso de integraci\u00f3n de PayPal en una aplicaci\u00f3n Spring Boot. Empezamos creando los DTOs necesarios para manejar las solicitudes y respuestas de la API de PayPal. Configuramos las propiedades de la aplicaci\u00f3n para incluir las credenciales y la URL base de PayPal. Luego, implementamos el servicio PaypalService con m\u00e9todos para obtener el token de acceso, crear \u00f3rdenes y capturar \u00f3rdenes. Finalmente, implementamos el controlador CheckoutController con endpoints para crear y capturar \u00f3rdenes de PayPal. Este flujo permite manejar pagos de forma eficiente y segura en una aplicaci\u00f3n Spring Boot.</p>"},{"location":"referencia/","title":"Referencias","text":"<ol> <li>Guia de Recursos de Java</li> <li>Lombok</li> <li>JPA Query M\u00e9todos</li> <li>Templates</li> <li>C\u00f3digo de HTTP</li> <li>Systems Starters</li> <li>Redis</li> <li>Redis-Calendario</li> </ol>"},{"location":"resource-java/","title":"Resource java","text":""},{"location":"resource-java/#programas","title":"Programas","text":"<ul> <li>Open JDK 21</li> <li>SDKMAN</li> <li>PostgreSQL</li> <li>Dbeaver</li> <li>IntelliJ IDEA</li> <li>Postman</li> <li>Visual Studio Code</li> <li>Docker &amp; DockerCompose</li> <li>Portainer</li> </ul>"},{"location":"resource-java/#dependencias-maven","title":"Dependencias Maven","text":"<ul> <li> Web</li> <li> DevTools</li> <li> Spring Data JPA</li> <li> PostgreSQL Driver</li> <li> Lombok</li> <li> Validation</li> <li> Flyway</li> <li> ModelMapper</li> <li> Security</li> <li> JWT</li> </ul>"},{"location":"resource-java/#enlaces-utiles","title":"Enlaces \u00fatiles","text":"<ul> <li>Spring initialzr</li> </ul>"},{"location":"spring-aop/","title":"Anotaciones con Spring AOP","text":""},{"location":"spring-aop/#que-es-aop","title":"\u00bfQu\u00e9 es AOP?","text":"<p>La Programaci\u00f3n Orientada a Aspectos (AOP, por sus siglas en ingl\u00e9s) es un paradigma de programaci\u00f3n que busca extraer funcionalidades transversales, como el registro de logs, en lo que se conoce como \"Aspectos\".</p> <p>Esto se logra a\u00f1adiendo comportamiento (\"Advice\") al c\u00f3digo existente sin cambiar el propio c\u00f3digo. Especificamos a qu\u00e9 c\u00f3digo queremos a\u00f1adir el comportamiento utilizando expresiones especiales (\"Pointcuts\").</p> <p>Por ejemplo, podemos indicarle al framework de AOP que registre todas las llamadas a m\u00e9todos que ocurren en el sistema sin tener que a\u00f1adir manualmente la declaraci\u00f3n de registro en cada llamada a m\u00e9todo.</p>"},{"location":"spring-aop/#spring-aop","title":"Spring AOP","text":"<p>AOP Es uno de los componentes principales en el framework Spring. Nos proporciona servicios declarativos, como la gesti\u00f3n de transacciones declarativas (la famosa anotaci\u00f3n <code>@Transactional</code>). Adem\u00e1s, nos ofrece la capacidad de implementar Aspectos personalizados y utilizar el poder de AOP en nuestras aplicaciones.</p> <p>Spring AOP utiliza proxies din\u00e1micos de JDK o CGLIB para crear el proxy de un objeto objetivo determinado. Los proxies din\u00e1micos de JDK est\u00e1n integrados en el JDK, mientras que CGLIB es una biblioteca com\u00fan de definici\u00f3n de clases de c\u00f3digo abierto (reempaquetada en <code>spring-core</code>).</p> <p>Si el objeto objetivo a ser proxificado implementa al menos una interfaz, se utiliza un proxy din\u00e1mico de JDK. Todas las interfaces implementadas por el tipo objetivo son proxificadas. Si el objeto objetivo no implementa ninguna interfaz, se crea un proxy de CGLIB.</p>"},{"location":"spring-aop/#terminologia-basica-de-aop","title":"Terminolog\u00eda b\u00e1sica de AOP","text":"<p>Las terminolog\u00edas que discutiremos no son espec\u00edficas de Spring, son conceptos generales de AOP que Spring implementa.</p> <p>Empecemos presentando los cuatro bloques principales de cualquier ejemplo de AOP en Spring.</p>"},{"location":"spring-aop/#joinpoint","title":"JoinPoint","text":"<p>En t\u00e9rminos simples, un JoinPoint es un punto en el flujo de ejecuci\u00f3n de un m\u00e9todo donde se puede insertar un Aspecto (nuevo comportamiento).</p>"},{"location":"spring-aop/#advice","title":"Advice","text":"<p>Es el comportamiento que aborda preocupaciones a nivel del sistema (registro de logs, comprobaciones de seguridad, etc.). Este comportamiento est\u00e1 representado por un m\u00e9todo que se ejecutar\u00e1 en un JoinPoint. Este comportamiento puede ejecutarse Antes, Despu\u00e9s o Alrededor del JoinPoint, seg\u00fan el tipo de Advice, como veremos m\u00e1s adelante.</p>"},{"location":"spring-aop/#pointcut","title":"Pointcut","text":"<p>Un Pointcut es una expresi\u00f3n que define en qu\u00e9 JoinPoints se debe aplicar un Advice determinado.</p>"},{"location":"spring-aop/#aspect","title":"Aspect","text":"<p>Aspect es una clase en la que definimos Pointcuts y Advices.</p>"},{"location":"spring-aop/#creacion-y-uso-de-anotaciones-con-spring-aop","title":"Creaci\u00f3n y Uso de Anotaciones con Spring AOP","text":"<p>En esta secci\u00f3n, vamos a mostrar c\u00f3mo simplificar la gesti\u00f3n de errores creando anotaciones personalizadas y utilizando Spring AOP.</p>"},{"location":"spring-aop/#paso-1-codigo-inicial-sin-aop","title":"Paso 1: C\u00f3digo Inicial Sin AOP","text":"<p>Supongamos que tenemos el siguiente m\u00e9todo en nuestra clase <code>BookService</code>:</p> Log.java<pre><code>public Optional&lt;Book&gt; getBookByCode(String code) {\n        logger.info(\"Starting book by code validations before getting the information\", code);\n        try {\n            return bookRepository.findByCode(code).map(BookMapper::toBook);\n        } catch (Exception e) {\n            logger.error(\"Error accessing data for book with code: {}\", code, e);\n            throw new BookNotFoundException(\"Book not found with code: \" + code);\n        }\n    }\n</code></pre> <p>Estamos registrando manualmente mensajes de log antes y despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo, as\u00ed como en caso de error. Vamos a simplificar y centralizar este comportamiento utilizando AOP.</p>"},{"location":"spring-aop/#paso-2-incluir-dependencias-en-el-pomxml","title":"Paso 2: Incluir Dependencias en el pom.xml","text":"<p>Primero, incluimos las dependencias necesarias para AOP en nuestro archivo <code>pom.xml</code>.</p> pom.xml<pre><code>&lt;dependencies&gt; \n     &lt;dependency&gt; \n         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  \n         &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;  \n         &lt;version&gt;2.7.4&lt;/version&gt;  \n     &lt;/dependency&gt;\n &lt;/dependencies&gt;\n</code></pre> <ul> <li><code>spring-boot-starter-aop</code>: Incluye las dependencias necesarias para utilizar Aspect-Oriented Programming (AOP) en Spring Boot.</li> </ul>"},{"location":"spring-aop/#paso-3-crear-la-anotacion-log","title":"Paso 3: Crear la Anotaci\u00f3n Log","text":"<p>Creamos una anotaci\u00f3n llamada <code>Log</code> que ser\u00e1 utilizada para interceptar m\u00e9todos y registrar mensajes en la consola.</p> Log.java<pre><code>import java.lang.annotation.ElementType;  \nimport java.lang.annotation.Retention;  \nimport java.lang.annotation.RetentionPolicy;  \nimport java.lang.annotation.Target;  \n\n@Target(ElementType.METHOD)  \n@Retention(RetentionPolicy.RUNTIME)  \npublic @interface Log {  \n}\n</code></pre> <ul> <li><code>@interface</code>: Utilizado para definir una anotaci\u00f3n personalizada en Java. Las anotaciones son un mecanismo para agregar metadatos a tu c\u00f3digo. En este caso, estamos creando una anotaci\u00f3n llamada Log.</li> <li><code>@Target(ElementType.METHOD)</code>: Indica que esta anotaci\u00f3n solo se puede aplicar a m\u00e9todos.</li> <li><code>@Retention(RetentionPolicy.RUNTIME)</code>: Indica que la anotaci\u00f3n estar\u00e1 disponible en tiempo de ejecuci\u00f3n, permitiendo que los aspectos de AOP la intercepten.</li> </ul>"},{"location":"spring-aop/#paso-4-implementar-un-aspecto-para-manejar-la-anotacion","title":"Paso 4: Implementar un Aspecto para Manejar la Anotaci\u00f3n","text":"<p>En este paso, vamos a implementar un aspecto que maneje la anotaci\u00f3n <code>Log</code> y registre mensajes personalizados antes, despu\u00e9s y en caso de una excepci\u00f3n durante la ejecuci\u00f3n del m\u00e9todo. Este aspecto permitir\u00e1 centralizar el logging de manera que no tengamos que repetir c\u00f3digo en cada m\u00e9todo.</p> LogginAspect.java<pre><code>import org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Component;\n\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n@Component\n@Aspect\npublic class LoggingAspect {\n    private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n\n    @Around(\"@annotation(com.jconfdominicana.bookstore.aspect.Loggable)\")\n    public Object logExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n        Loggable loggable = getLoggableAnnotation(joinPoint);\n        String className = joinPoint.getSignature().toShortString();\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        String[] parameterNames = methodSignature.getParameterNames();\n        Object[] arguments = joinPoint.getArgs();\n        String argsString = IntStream.range(0, arguments.length)\n                .mapToObj(i -&gt; parameterNames[i] + \"=\" + arguments[i])\n                .collect(Collectors.joining(\", \"));\n\n        try {\n            logger.info(\"{} from {} with arguments {}\", loggable.startMessage(), className, argsString);\n            Object response = joinPoint.proceed();\n            logger.info(\"{} from {} with result: {}\", loggable.endMessage(), className, response);\n            return response;\n        } catch (Throwable e) {\n            logger.error(\"{} error=[{}] thrown from {} with arguments {}\", loggable.errorMessage(), e.getMessage(), className, argsString);\n            throw e;\n        }\n    }\n\n    private Loggable getLoggableAnnotation(ProceedingJoinPoint joinPoint) {\n        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n        return methodSignature.getMethod().getAnnotation(Loggable.class);\n    }\n}\n</code></pre> <ul> <li> <p>Anotaciones y Componentes</p> <ul> <li>@Component: Indica que esta clase es un componente gestionado por Spring, permitiendo que sea detectada y registrada como un bean en el contexto de Spring.</li> <li>@Aspect: Indica que esta clase define un aspecto, que es una modularizaci\u00f3n de una preocupaci\u00f3n transversal (como el logging) que puede aplicarse a varios puntos de la aplicaci\u00f3n.</li> </ul> </li> <li> <p>L\u00ednea 15:  <pre><code>private static final Logger logger = LoggerFactory.getLogger(LoggingAspect.class);\n</code></pre></p> </li> <li><code>Logger logger</code>: Utiliza SLF4J y Logback para registrar mensajes de log. <code>LoggerFactory.getLogger(LoggingAspect.class)</code> crea una instancia de logger espec\u00edfica para esta clase.</li> </ul> <p>Advice <code>@Around</code></p> <pre><code>@Around(\"@annotation(com.jconfdominicana.bookstore.aspect.Loggable)\")\npublic Object logExecution(ProceedingJoinPoint joinPoint) throws Throwable {\n</code></pre> <ul> <li>@Around(\"@annotation(com.jconfdominicana.bookstore.aspect.Loggable)\"): Define un advice que se ejecuta alrededor de la ejecuci\u00f3n de m\u00e9todos  anotados con @Loggable. Esto significa que el advice se ejecutar\u00e1 antes, durante y despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo.</li> <li>ProceedingJoinPoint joinPoint: Representa el punto de ejecuci\u00f3n del m\u00e9todo interceptado, permitiendo ejecutar el m\u00e9todo y obtener informaci\u00f3n sobre \u00e9l.</li> </ul> <p>Obtener la Anotaci\u00f3n Loggable</p> <pre><code>Loggable loggable = getLoggableAnnotation(joinPoint);\n</code></pre> <ul> <li>Loggable loggable: Obtiene la instancia de la anotaci\u00f3n Loggable del m\u00e9todo interceptado para acceder a sus valores. Obtener Informaci\u00f3n del M\u00e9todo</li> </ul> <pre><code>String className = joinPoint.getSignature().toShortString();\nMethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\nString[] parameterNames = methodSignature.getParameterNames();\nObject[] arguments = joinPoint.getArgs();\nString argsString = IntStream.range(0, arguments.length)\n        .mapToObj(i -&gt; parameterNames[i] + \"=\" + arguments[i])\n        .collect(Collectors.joining(\", \"));\n</code></pre> <ul> <li>className: Obtiene el nombre del m\u00e9todo interceptado.</li> <li>MethodSignature methodSignature: Convierte la firma del punto de ejecuci\u00f3n en una firma de m\u00e9todo para obtener m\u00e1s detalles.</li> <li>parameterNames: Obtiene los nombres de los par\u00e1metros del m\u00e9todo.</li> <li>arguments: Obtiene los valores de los argumentos del m\u00e9todo.</li> <li>argsString: Convierte los nombres y valores de los par\u00e1metros en una cadena para su registro.</li> </ul> <p>Registro de Mensajes y Ejecuci\u00f3n del M\u00e9todo</p> <pre><code>try {\n    logger.info(\"{} from {} with arguments {}\", loggable.startMessage(), className, argsString);\n    Object response = joinPoint.proceed();\n    logger.info(\"{} from {} with result: {}\", loggable.endMessage(), className, response);\n    return response;\n} catch (Throwable e) {\n    logger.error(\"{} error=[{}] thrown from {} with arguments {}\", loggable.errorMessage(), e.getMessage(), className, argsString);\n    throw e;\n}\n</code></pre> <ul> <li>logger.info: Registra el mensaje de inicio con los argumentos del m\u00e9todo.</li> <li>Object response = joinPoint.proceed(): Ejecuta el m\u00e9todo interceptado y obtiene su resultado.</li> <li>logger.info: Registra el mensaje de finalizaci\u00f3n con el resultado del m\u00e9todo.</li> <li>catch (Throwable e): Captura cualquier excepci\u00f3n lanzada durante la ejecuci\u00f3n del m\u00e9todo.</li> <li>logger.error: Registra el mensaje de error con la excepci\u00f3n lanzada.</li> <li>throw e: Vuelve a lanzar la excepci\u00f3n para que el flujo de control original no se vea alterado.</li> </ul> <p>M\u00e9todo Auxiliar <code>getLoggableAnnotation</code></p> <pre><code>private Loggable getLoggableAnnotation(ProceedingJoinPoint joinPoint) {\n    MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();\n    return methodSignature.getMethod().getAnnotation(Loggable.class);\n}\n</code></pre> <ul> <li>MethodSignature methodSignature: Convierte la firma del punto de ejecuci\u00f3n en una firma de m\u00e9todo.</li> <li>methodSignature.getMethod().getAnnotation(Loggable.class): Obtiene la anotaci\u00f3n Loggable del m\u00e9todo interceptado.</li> </ul>"},{"location":"spring-aop/#paso-5-crear-mensajes-de-servicio","title":"Paso 5: Crear Mensajes de Servicio","text":"<p>Esta clase contiene constantes con mensajes utilizados en el logging.</p> LoggingAspect.java<pre><code>public class BookServiceMessages {\n    public static final String STARTING_BOOK_BY_CODE_VALIDATIONS = \"Starting book by code validations before getting the information\";\n    public static final String END_BOOK_MESSAGE = \"Book retrieval by code completed\";\n    public static final String ERROR_ACCESSING_DATA_FOR_BOOK = \"Error accessing data for book with code: {}\";\n    public static final String BOOK_NOT_FOUND_WITH_CODE = \"Book not found with code: \";\n    public static final String UNEXPECTED_ERROR_SAVING_BOOK = \"Unexpected error saving book: {}\";\n}\n</code></pre>"},{"location":"spring-aop/#paso-6-aplicar-la-anotacion-loggable-en-el-servicio","title":"Paso 6: Aplicar la Anotaci\u00f3n Loggable en el Servicio","text":"<p>Finalmente, aplicamos la anotaci\u00f3n <code>Loggable</code> en el m\u00e9todo <code>getBookByCode</code> del servicio <code>BookService</code>.</p> LoggingAspect.java<pre><code>@Loggable(startMessage = BookServiceMessages.STARTING_BOOK_BY_CODE_VALIDATIONS,\n          endMessage = BookServiceMessages.END_BOOK_MESSAGE,\n          errorMessage = BookServiceMessages.ERROR_ACCESSING_DATA_FOR_BOOK)\npublic Optional&lt;Book&gt; getBookByCode(String code) {\n    try {\n        return bookRepository.findByCode(code).map(BookMapper::toBook);\n    } catch (Exception e) {\n        throw new BookNotFoundException(BookServiceMessages.BOOK_NOT_FOUND_WITH_CODE + code);\n    }\n}\n</code></pre> <ul> <li>@Loggable(startMessage = ..., endMessage = ..., errorMessage = ...): Aplica la anotaci\u00f3n <code>Loggable</code> al m\u00e9todo, especificando los mensajes personalizados para inicio, fin y error.</li> </ul>"},{"location":"spring-aop/#conclusiones","title":"Conclusiones","text":"<p>En esta sesi\u00f3n, hemos mostrado c\u00f3mo configurar Spring AOP para crear una anotaci\u00f3n personalizada <code>Loggable</code> que intercepta m\u00e9todos y registra mensajes personalizados antes, despu\u00e9s y en caso de una excepci\u00f3n durante la ejecuci\u00f3n del m\u00e9todo. Esta configuraci\u00f3n facilita el registro de logs detallados y consistentes, mejorando la capacidad de depuraci\u00f3n y monitoreo de la aplicaci\u00f3n.</p>"},{"location":"testing-book/","title":"Pruebas en Aplicaciones de SpringBoot","text":""},{"location":"testing-book/#pruebas-unitarias-con-junit-5-y-mockito","title":"Pruebas unitarias con JUnit 5 y Mockito","text":"<p>Empecemos a escribir pruebas unitarias para <code>UserService</code>. Deber\u00edamos ser capaces de escribir pruebas unitarias para <code>UserService</code> SIN usar ninguna funcionalidad de Spring.</p> <p>Vamos a crear un simulacro de <code>UserRepository</code> utilizando <code>Mockito.mock()</code> y crearemos una instancia de <code>UserService</code> utilizando el simulacro de <code>UserRepository</code>.</p> UserServiceTest.java<pre><code>public class UserServiceTest {\n\n    private UserService userService;\n\n    private UserRepository userRepository;\n\n    @BeforeEach\n    void setUp() {\n        userRepository = Mockito.mock(UserRepository.class);\n        userService = new UserService(userRepository);\n    }\n\n@Test\nvoid shouldSaveUserSuccessfully() {\n    User user = new User(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny@gmail.com\", \"password123\", \"1234567890\", Role.USER);\n    UserEntity userEntity = new UserEntity(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny@gmail.com\", \"password123\", \"1234567890\", Role.USER, LocalDateTime.now(), null);\n    UserEntity savedUserEntity = new UserEntity(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny@gmail.com\", \"password123\", \"1234567890\", Role.USER, LocalDateTime.now(), LocalDateTime.now());\n    User savedUser = new User(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny@gmail.com\", \"password123\", \"1234567890\", Role.USER);\n\n    given(userRepository.existsByEmail(user.getEmail())).willReturn(false);\n    given(userRepository.save(any(UserEntity.class))).willReturn(savedUserEntity);\n\n    User result = userService.createUser(user);\n\n    assertThat(result).isNotNull();\n    assertThat(result.getId()).isEqualTo(1L);\n\n    verify(userRepository).existsByEmail(user.getEmail());\n    verify(userRepository).save(any(UserEntity.class));\n}\n\n@Test\nvoid shouldThrowErrorWhenSavingUserWithExistingEmail() {\n    User user = new User(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny1@gmail.com\", \"password123\", \"1234567890\", Role.USER);\n   given(userRepository.existsByEmail(user.getEmail())).willReturn(true);\n\n    assertThrows(EmailAlreadyExistsException.class, () -&gt; {\n        userService.createUser(user);\n    });\n\n    verify(userRepository).existsByEmail(user.getEmail());\n    verify(userRepository, never()).save(any(UserEntity.class));\n\n}\n}\n</code></pre> <p>He creado el objeto mock <code>UserRepository</code> y la instancia <code>UserService</code> en el m\u00e9todo <code>@BeforeEach</code> para que cada prueba tenga una configuraci\u00f3n limpia. Aqu\u00ed no estamos utilizando ninguna funci\u00f3n de pruebas de Spring o SpringBoot como <code>@SpringBootTest</code> porque no es necesario para probar el comportamiento de <code>UserService</code>.</p> <p>No voy a escribir tests para otros m\u00e9todos porque simplemente est\u00e1n delegando las llamadas a <code>UserRepository</code>.</p>"},{"location":"testing-book/#uso-de-anotaciones-para-crear-mocks","title":"Uso de Anotaciones para Crear Mocks","text":"<p>Si prefieres utilizar la magia de las anotaciones para crear un mock de <code>UserRepository</code> e inyectarlo en <code>UserService</code>, puedes utilizar <code>mockito-junit-jupiter</code> de la siguiente manera:</p> <p>A\u00f1ade la dependencia mockito-junit-jupiter</p> <pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mockito&lt;/groupId&gt;\n    &lt;artifactId&gt;mockito-junit-jupiter&lt;/artifactId&gt;\n    &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre> <p>Utilice <code>@Mock</code> y <code>@InjectMocks</code> para crear e inyectar objetos simulados como se indica a continuaci\u00f3n:</p> UserServiceAnnotatedTest.java<pre><code>@ExtendWith(MockitoExtension.class)\nclass UserServiceAnnotatedTest {\n\n    @Mock\n    private UserRepository userRepository;\n\n    @InjectMocks\n    private UserService userService;\n\n    ...\n    ...\n}\n</code></pre>"},{"location":"testing-book/#pruebas-unitarias-para-el-controlador","title":"Pruebas Unitarias para el Controlador","text":"<p>S\u00ed, quiero escribir pruebas unitarias para el controlador y quiero comprobar si el punto final REST est\u00e1 dando el ResponseCode HTTP adecuado o no, devolviendo el JSON esperado o no, etc.</p> <p>SpringBoot proporciona la anotaci\u00f3n <code>@WebMvcTest</code> para probar los controladores MVC de Spring. Adem\u00e1s, las pruebas basadas en <code>@WebMvcTest</code> se ejecutan m\u00e1s r\u00e1pido, ya que cargar\u00e1n \u00fanicamente el controlador especificado y sus dependencias sin cargar toda la aplicaci\u00f3n.</p> <p>Ahora podemos escribir tests para <code>UserController</code> inyectando un bean Mock <code>UserService</code> e invocar los endpoints de la API usando <code>MockMvc</code>.</p> <p>Como SpringBoot est\u00e1 creando la instancia <code>UserController</code>, estamos creando un mock bean UserService utilizando <code>@MockBean</code> de Spring en lugar de <code>@Mock</code> de Mockito.</p> UserControllerTest.java<pre><code>@WebMvcTest(UserController.class)\npublic class UserControllerTest {\n    @Autowired\n    private MockMvc mockMvc;\n\n    @MockBean\n    private UserService userService;\n\n    private User user;\n\n    @BeforeEach\n    void setUp() {\n        user = new User(1L, \"Geovanny\", \"Mendoza\", \"Geovanny Mendoza\", \"geovanny@gmail.com\", \"password123\", \"1234567890\", Role.USER);\n    }\n\n    @Test\n    void shouldReturnListOfUsers() throws Exception {\n        List&lt;User&gt; users = Collections.singletonList(user);\n        given(userService.getUsers()).willReturn(users);\n\n        mockMvc.perform(get(\"/api/users\")\n                        .contentType(MediaType.APPLICATION_JSON))\n                .andExpect(status().isOk())\n                .andExpect(content().json(\"[{'id':1,'firstName':'Geovanny','lastName':'Mendoza','fullName':'Geovanny Mendoza','email':'geovanny@gmail.com','password':'password123','phone':'1234567890','role':'USER'}]\"));\n    }\n\n    @Test\n    void shouldCreateUserSuccessfully() throws Exception {\n        given(userService.createUser(any(User.class))).willReturn(user);\n\n        mockMvc.perform(post(\"/api/users\")\n                        .contentType(MediaType.APPLICATION_JSON)\n                        .content(\"{\\\"firstName\\\":\\\"Geovanny\\\",\\\"lastName\\\":\\\"Mendoza\\\",\\\"fullName\\\":\\\"Geovanny Mendoza\\\",\\\"email\\\":\\\"geovanny@gmail.com\\\",\\\"password\\\":\\\"password123\\\",\\\"phone\\\":\\\"1234567890\\\",\\\"role\\\":\\\"USER\\\"}\"))\n                .andExpect(status().isCreated())\n                .andExpect(content().json(\"{'id':1,'firstName':'Geovanny','lastName':'Mendoza','fullName':'Geovanny Mendoza','email':'geovanny@gmail.com','password':'password123','phone':'1234567890','role':'USER'}\"));\n    }\n}\n</code></pre> <p>Ahora tenemos una buena cantidad de pruebas unitarias probando varios componentes de nuestra aplicaci\u00f3n. Pero todav\u00eda hay muchas posibilidades de que las cosas vayan mal, puede ser que tengamos algunos problemas de configuraci\u00f3n de propiedades, podemos tener algunos errores en nuestros scripts de migraci\u00f3n de base de datos, etc etc.</p> <p>Por lo tanto, escribamos Pruebas de Integraci\u00f3n para tener m\u00e1s confianza en que nuestra aplicaci\u00f3n se est\u00e1 ejecutando correctamente.</p>"},{"location":"testing-book/#pruebas-de-integracion-con-testcontainer","title":"Pruebas de integraci\u00f3n con TestContainer","text":"<p>SpringBoot proporciona un excelente soporte para las pruebas de integraci\u00f3n. Podemos utilizar la anotaci\u00f3n <code>@SpringBootTest</code> para cargar el contexto de la aplicaci\u00f3n y probar varios componentes.</p> <p>Empecemos escribiendo pruebas de integraci\u00f3n para <code>UserController</code>. Como he mencionado antes, queremos probar el uso de la base de datos Postgres en lugar de la base de datos en memoria.</p> <p>A\u00f1ade las siguientes dependencias.</p> <pre><code>&lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-testcontainers&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.testcontainers&lt;/groupId&gt;\n            &lt;artifactId&gt;postgresql&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;io.rest-assured&lt;/groupId&gt;\n            &lt;artifactId&gt;rest-assured&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n</code></pre> <p>Podemos utilizar el soporte TestContainers para JUnit 5 como se menciona aqu\u00ed (https://www.testcontainers.org/test_framework_integration/junit_5/). Sin embargo, iniciar y detener los contenedores docker para cada prueba o cada clase de prueba podr\u00eda causar que las pruebas se ejecuten lentamente. Por lo tanto, vamos a utilizar el enfoque de Singleton Containers mencionado en (https://www.testcontainers.org/test_framework_integration/manual_lifecycle_control/#singleton-containers).</p> <p>Vamos a crear una clase base <code>AbstractIT</code> para que todos nuestros tests de integraci\u00f3n puedan extenderse sin repetir la configuraci\u00f3n com\u00fan.</p> AbstractIT.java<pre><code>@SpringBootTest(webEnvironment = RANDOM_PORT)\n@Import(ContainersConfig.class)\npublic abstract class AbstractIT {\n    @LocalServerPort\n    int port;\n\n    @BeforeEach\n    void setUp() {\n        RestAssured.port = port;\n    }\n\n}\n</code></pre> BookstoreApplicationTests.java<pre><code>@SpringBootTest\nclass BookstoreApplicationTests extends AbstractIT {\n\n    @Test\n    void contextLoads() {}\n}\n</code></pre> <p>Hemos utilizado <code>@AutoConfigureMockMvc</code> para autoconfigurar <code>MockMvc</code>, y <code>@SpringBootTest</code>(webEnvironment = RANDOM_PORT) para iniciar el servidor en un puerto disponible aleatorio.</p> <p>Hemos arrancado PostgreSQLContainer y utilizado @ContextConfiguration(initializers={AbstractIntegrationTest.Initializer.class}) para configurar las propiedades de conexi\u00f3n din\u00e1mica a la base de datos.</p> <p>Ahora podemos implementar la Prueba de Integraci\u00f3n para BookController de la siguiente manera:</p> BookControllerTest.java<pre><code>@Sql(\"/test-data.sql\")\npublic class BookControllerTest extends AbstractIT {\n\n    @Test\n    void shouldReturnBooks() {\n        given().contentType(ContentType.JSON)\n                .when()\n                .get(\"/api/books\")\n                .then()\n                .statusCode(200)\n                .body(\"data\", hasSize(10))\n                .body(\"totalElements\", is(15))\n                .body(\"pageNumber\", is(1))\n                .body(\"totalPages\", is(2))\n                .body(\"isFirst\", is(true))\n                .body(\"isLast\", is(false))\n                .body(\"hasNext\", is(true))\n                .body(\"hasPrevious\", is(false));\n    }\n}\n</code></pre> <p>Las pruebas de BookControllerIT son muy similares a las de UserControllerTest, con la diferencia de c\u00f3mo cargamos el ApplicationContext. Si utilizamos @SpringBootTest, SpringBoot iniciar\u00e1 la aplicaci\u00f3n cargando la aplicaci\u00f3n completa, por lo que las pruebas fallar\u00e1n si hay alg\u00fan error de configuraci\u00f3n.</p> <p>A continuaci\u00f3n, vamos a escribir pruebas para UserRepository utilizando @DataJpaTest. Pero queremos ejecutar las pruebas contra una base de datos real no con una base de datos en memoria. Podemos utilizar @AutoConfigureTestDatabase(replace=AutoConfigureTestDatabase.Replace.NONE) para desactivar el uso de la base de datos en memoria y utilizar la base de datos configurada.</p> <p>Vamos a crear PostgreSQLContainerInitializer para que cualquier prueba de repositorio pueda utilizarlo para configurar las propiedades din\u00e1micas de la base de datos Postgres.</p> ContainersConfig.java<pre><code>@TestConfiguration(proxyBeanMethods = false)\npublic class ContainersConfig {\n    @Bean\n    @ServiceConnection\n    PostgreSQLContainer&lt;?&gt; postgresContainer() {\n        return new PostgreSQLContainer&lt;&gt;(DockerImageName.parse(\"postgres:16-alpine\"));\n    }\n}\n</code></pre> <p>Ahora podemos crear BookRepositoryTest de la siguiente manera:</p> BookRepositoryTest.java<pre><code>@DataJpaTest(\n        properties = {\n                \"spring.test.database.replace=none\",\n                \"spring.datasource.url=jdbc:tc:postgresql:16-alpine:///db\",\n        })\n@Sql(\"/test-data.sql\")\npublic class BookRepositoryTest {\n    @Autowired\n    private BookRepository bookRepository;\n\n    @Test\n    void shouldGetAllProducts() {\n        List&lt;BookEntity&gt; books = bookRepository.findAll();\n        assertThat(books).hasSize(15);\n    }\n}\n</code></pre> <p>Bueno, supongo que hemos aprendido algo sobre c\u00f3mo escribir pruebas unitarias y pruebas de integraci\u00f3n utilizando varias caracter\u00edsticas de SpringBoot.</p>"},{"location":"testing-book/#conclusion","title":"Conclusion","text":""}]}